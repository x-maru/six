<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=11">
<title>Vi-like Text Editor "six" v0.3.3</title>
<hta:application
  id="app"
  applicationname="six"
  border="thin"
  caption="yes"
  sysmenu="yes"
  singleinstance="yes"
  scroll="no"
/>
<style>
  html, body {
    height: 100%;
    margin: 0;
    background: #1e1f22;
    color: #ddd;
    font-family: Consolas, "Courier New", monospace;
  }
  #pane { position: relative; height: 100%; }
  /* 本文ストライプ（偶数行デバッグ用オーバーレイ） */
  #edstripe {
    position: absolute; top: 0; bottom: 0; left: 0; right: 0;
    pointer-events: none; z-index: 0; /* editor(=1) の下, gutter(z=2) の下 */
    background-repeat: repeat;
  }
  /* 行番号ガター */
  #gutter {
    position: absolute; top: 0; bottom: 0; left: 0;
    width: 72px; background: #1b1c1f; border-right: 1px solid #3b3d42;
    color: #c0c0c0; text-align: right; padding-right: 8px; box-sizing: border-box;
    font-size: 21px; line-height: 1.6; pointer-events: none; overflow: hidden;
    z-index: 2; /* ←追加 */
  }
  #gutter .ln { height: auto; }
  /* 本文 */
  #editor {
    position: absolute; top: 0; bottom: 0; right: 0; left: 0;
    width: 100%; height: 100%;
    box-sizing: border-box; padding: 10px; padding-left: 82px; /* number=on */
    background: transparent; color: #ddd; border: none; outline: none; resize: none;
    font-size: 21px; line-height: 1.6; caret-color: #fff;
    z-index: 1; /* ストライプより上に表示 */
  }
  /* コマンドバー（:） */
  #cmdbar {
    position: absolute; left: 0; right: 0; bottom: 0;
    height: 64px;
    background: #222; color: #fff;
    border-top: 1px solid #3b3d42; font-size: 14px;
    display: flex; flex-direction: column; z-index: 10;
  }
  #statusline1 {
    display: flex;
    align-items: center;
    width: 100%;
    height: 28px;
    overflow: hidden;
  }
  #filename, #modmark, #mode, #pos {
    flex: 0 0 auto;
    min-width: 80px;
    max-width: 160px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  #hint {
    flex: 1 1 auto;
    text-align: center;
    min-width: 120px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  #cmdprefix, #cmdline {
    position: static;
    font-size: 14px;
    height: 28px;
    margin: 0;
    background: #232323;
    color: #fff;
    border: none;
    box-sizing: border-box;
    display: inline-block;
    vertical-align: middle;
  }
  #cmdline {
    width: calc(100% - 32px);
    padding: 4px 12px;
    border: 1px solid #3b3d42;
    color: #fff;
    background: #232323;
    outline: none;
    font-family: inherit;
    margin-left: 0;
    margin-right: 0;
    display: none;
    height: 28px;
  }
  #cmdmsg {
    display: none;
    position: absolute;
    left: 0; top: 0; width: 100%; height: 100%;
    background: #232323; color: #ffd;
    font-size: 14px;
    padding: 4px 12px;
    box-sizing: border-box;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    z-index: 12;
    height: 28px;
  }
  /* ヘルプオーバーレイ */
  #help {
    position: absolute; left: 5%; right: 5%; top: 8%; bottom: 8%;
    border: 1px solid #3b3d42; background: rgba(30,31,34,0.98);
    display: none; z-index: 4; box-shadow: 0 8px 24px rgba(0,0,0,.4);
    padding: 16px; overflow: hidden; font-size: 14px; line-height: 1.6; /* ← overflow を hidden に */
  }
  #help h2 { margin: 0 0 8px; font-size: 16px; }
  #help kbd {
    background: #444; color: #fff; padding: 1px 4px; border-radius: 3px; font-size: 12px;
  }
  #help pre { background:#15161a; padding:8px; overflow:auto; }
  /* 追加: ヘルプのスクロール領域/固定フッター */
  #helpScroll {
    position: absolute; left: 16px; right: 16px; top: 16px; bottom: 48px;
    overflow: auto; outline: none;
  }
  #helpFooter {
    position: absolute; left: 16px; right: 16px; bottom: 12px; height: 32px;
    text-align: right;
    font-size: 15px; /* 文字を少し大きく */
  }
  /* 追加: フッター左側にヘルプ用キー案内 */
  #helpKeys {
    float: left; color: #bbb; font-size: 15px; line-height: 32px;
  }
  /* ちょいメッセージ（右下トースト） */
  #msg {
    position: absolute; right: 12px; bottom: 40px; z-index: 5;
    background: #2b2d31; border: 1px solid #3b3d42; color: #ddd;
    padding: 6px 10px; border-radius: 4px; font-size: 12px; display: none;
  }
  /* ステータスバー */
  #statusbar {
    position: absolute; left: 0; right: 0; bottom: 0;
    height: 28px; background: #222; color: #fff;
    border-top: 1px solid #3b3d42; font-size: 14px;
    display: flex; align-items: center; padding-left: 12px; z-index: 10;
  }
  #statusline2 {
    width: 100%;
    height: 28px;
    border-top: 2px solid #555;
    background: #232323;
    position: relative;
    z-index: 11;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  /* 右下リサイズハンドル（IE9でもドラッグで window.resizeBy） */
  #winresizer{ position:absolute; right:6px; bottom:34px; width:14px; height:14px; cursor:se-resize; z-index:50; }
  #winresizer:before{ content:''; position:absolute; right:0; bottom:0; width:0; height:0;
    border-right:14px solid #666; border-top:14px solid transparent; opacity:.5; }
  #winresizer:hover:before{ border-right-color:#aaa; opacity:.8; }
</style>
</head>
<body>
  <!-- 画面下部コマンド/ステータス/メッセージバー（統合） -->
  <div id="cmdbar" tabindex="0">
    <div id="statusline1">
      <span id="filename"></span>
      <span id="modmark"></span>
      <span id="mode"></span>
      <span id="pos"></span>
      <span id="hint"></span>
    </div>
    <div id="statusline2">
      <div id="cmdmsg" style="display:none;"></div>
      <span id="cmdprefix" style="display:none">:</span>
      <input id="cmdline" type="text" style="display:none" />
    </div>
  </div>
  <div id="pane">
    <div id="edstripe"></div>
    <div id="gutter"></div>
    <textarea id="editor" spellcheck="false" wrap="off"
      placeholder="ここにテキストを入力…&#10;NORMALでは h j k l / ←↓↑→ / w b / ^ 0 $ / gg G、行挿入 o/O、挿入 a/A、行頭 I。&#10;/ と ? で検索、n/N で次/前。&#10;i で INSERT、Esc で NORMAL。:w で保存、:help でヘルプ。"></textarea>
  </div>
  <!-- ヘルプ（最小の“使えるコマンド一覧”） -->
  <div id="help">
    <div id="helpScroll" tabindex="0">
      <h2>ヘルプ</h2>
      <h2>起動時オプション（ファイルを渡して開く）</h2>
      <ul>
        <li>同フォルダ: <code>six.hta README.txt</code></li>
        <li>フルパス: <code>mshta.exe "C:\path\to\six.hta" "C:\path\to\memo.txt"</code></li>
        <li>空白を含むパスは引用符で囲む</li>
        <li>相対パスは「six.hta のあるフォルダ」を基準に解決</li>
        <li>存在すれば <strong>Loaded:</strong>、無ければ <strong>New file:</strong>（編集フラグ=0で開始）</li>
      </ul>
      <h2>NORMAL モード</h2>
      <ul>
        <li>移動: <kbd>h</kbd>/<kbd>j</kbd>/<kbd>k</kbd>/<kbd>l</kbd>（<kbd>←</kbd>/<kbd>↓</kbd>/<kbd>↑</kbd>/<kbd>→</kbd> でも可）</li>
        <li>語単位: <kbd>w</kbd>（次の語先頭） / <kbd>b</kbd>（前の語先頭）</li>
        <li>行内: <kbd>^</kbd>（先頭非空白） / <kbd>0</kbd>（行頭） / <kbd>$</kbd>（行末）</li>
        <li>段落: <kbd>{</kbd> / <kbd>}</kbd></li>
        <li>先頭/末尾行: <kbd>gg</kbd> / <kbd>G</kbd></li>
        <li>カウント: 数字前置（例: 5<kbd>j</kbd>, 3<kbd>w</kbd>, 2<kbd>dd</kbd>, 10<kbd>G</kbd>）</li>
        <li>削除:
          <ul>
            <li><kbd>x</kbd>（カーソル文字）</li>
            <li><kbd>d</kbd>＋モーション（<kbd>d</kbd><kbd>h</kbd>/<kbd>d</kbd><kbd>l</kbd>/<kbd>d</kbd><kbd>w</kbd>/<kbd>d</kbd><kbd>$</kbd> など）</li>
            <li><kbd>dd</kbd> / <code>N</code><kbd>dd</kbd>（行単位）</li>
            <li><kbd>d</kbd><kbd>gg</kbd> / <kbd>d</kbd><kbd>G</kbd>（現在行から先頭/末尾まで行単位）</li>
        <li>行挿入: <kbd>o</kbd>（下に新規行＋INSERT） / <kbd>O</kbd>（上に新規行＋INSERT）</li>
        <li>挿入: <kbd>a</kbd>（右へ1文字進んでINSERT） / <kbd>A</kbd>（行末でINSERT） / <kbd>I</kbd>（先頭非空白でINSERT）</li>
        <li>検索: <kbd>/</kbd>（前方） / <kbd>?</kbd>（後方）、<kbd>n</kbd>/<kbd>N</kbd> で次/前（入力中にプレビュー）</li>
          </ul>
        </li>
        <li>貼り付け: <kbd>p</kbd>（後） / <kbd>P</kbd>（前）
          <ul>
            <li>行単位レジスタは行として貼り付け、文字単位は位置に挿入</li>
            <li>VISUAL 選択中は置換貼り付け</li>
          </ul>
        </li>
        <li>モード切替: <kbd>i</kbd>（INSERT） / <kbd>v</kbd>（VISUAL） / <kbd>Esc</kbd>（NORMALへ）</li>
        <li>ステータス: 画面下に <code>Ln, Col, Sel, [+]</code> を表示。行番号は <kbd>:set number</kbd> で切替</li>
      </ul>
      <h2>VISUAL モード</h2>
      <ul>
        <li>開始/終了: <kbd>v</kbd> で開始 / <kbd>Esc</kbd> で終了</li>
        <li>選択: exclusive（右端は含めない）</li>
        <li>移動: <kbd>h</kbd>/<kbd>j</kbd>/<kbd>k</kbd>/<kbd>l</kbd>、<kbd>←</kbd>/<kbd>↓</kbd>/<kbd>↑</kbd>/<kbd>→</kbd>、<kbd>w</kbd>/<kbd>b</kbd>、<kbd>0</kbd>/<kbd>^</kbd>/<kbd>$</kbd>、<kbd>{</kbd>/<kbd>}</kbd>、<kbd>gg</kbd>/<kbd>G</kbd></li>
        <li>削除: <kbd>d</kbd> で選択削除（<kbd>d</kbd>＋モーションも可）</li>
        <li>貼り付け: <kbd>p</kbd>/<kbd>P</kbd> は選択範囲を置換</li>
        <li>カウント: 数字前置でモーションに適用（例: 5<kbd>j</kbd>）</li>
      </ul>
      <h2>:コマンド</h2>
      <ul>
        <li><kbd>:e</kbd> file … ファイルを開く（無ければ新規空で開始）
          <ul>
            <li>補完: <kbd>Tab</kbd>/<kbd>Shift+Tab</kbd> または <kbd>↑</kbd>/<kbd>↓</kbd> で候補巡回（自動挿入なし、選択時のみ反映）</li>
          </ul>
        </li>
        <li><kbd>:e!</kbd> / <kbd>:e!</kbd> file … 強制再読込（未保存変更を破棄）</li>
                <li><kbd>:ls</kbd> / <kbd>:buffers</kbd> … バッファ一覧を表示（コマンドバーに <code>:b </code> をセットし候補から選択可）</li>
                <li><kbd>:b</kbd> {id} / <kbd>:b</kbd> {名前} … バッファ切替（名前/パスは前方一致）。<code>%</code> は現在、<code>[+]</code> は未保存</li>
        <li><kbd>:w</kbd> / <kbd>:w</kbd> path … UTF-8（LF）で保存。保存後は編集フラグクリア＆Undo基点再構築</li>
        <li><kbd>:set number</kbd> / <kbd>:set nonumber</kbd> … 行番号表示の切替</li>
        <li><kbd>:set clipboard=os</kbd> / <kbd>:set clipboard=internal</kbd> … クリップボード同期先</li>
        <li><kbd>:set scrolloff=数字</kbd> … 画面端からの余白行数（既定=99999）</li>
        <li><kbd>:123</kbd> … 指定行へジャンプ（先頭非空白）</li>
        <li><kbd>:u</kbd> / <kbd>:redo</kbd> … Undo / Redo</li>
        <li><kbd>:help</kbd> … このヘルプを表示</li>
        <li><kbd>:q</kbd> / <kbd>:q!</kbd> … 終了（未保存変更を破棄して強制終了するには <kbd>:q!</kbd>）</li>
        <li><kbd>:debugscroll</kbd> … スクロール境界のデバッグ情報を表示</li>
      </ul>
      <p>注: ActiveX（FileSystemObject / ADODB.Stream）が無効な環境では、ファイル操作と補完は動作しません。</p>
    </div>
    <div id="helpFooter">
      <span id="helpKeys">
        ヘルプ中の操作:
        <kbd>j</kbd> /
        <kbd>k</kbd> /
        <kbd>↓</kbd> /
        <kbd>↑</kbd> /
        <kbd>Space</kbd> /
        <kbd>Shift</kbd>+<kbd>Space</kbd> /
        <kbd>gg</kbd> /
        <kbd>G</kbd>
      </span>
      <button onclick="hideHelp()">閉じる (Esc)</button>
    </div>
  </div>
  <div id="msg"></div>
<script>

// PATCH: define symbols used unquoted in motion blocks (w/b 等の互換用)
// 既に存在する場合は上書きしない（HTA/IE11 想定）
try{ if (typeof d==='undefined')     { window.d='d'; } }catch(_){ var d='d'; }
try{ if (typeof up==='undefined')    { window.up='up'; } }catch(_){ var up='up'; }
try{ if (typeof down==='undefined')  { window.down='down'; } }catch(_){ var down='down'; }
try{ if (typeof left==='undefined')  { window.left='left'; } }catch(_){ var left='left'; }
try{ if (typeof right==='undefined') { window.right='right'; } }catch(_){ var right='right'; }

// ====== オプション（:set 相当） ======
var OPT = {
  number: true,          // 行番号
  fileformat: 'unix',    // v1は LF 固定 ('unix')。将来 'dos' なら CRLF 正規化へ
  clipboard: 'internal', // 'internal' or 'os'（y/d 実装時に反映）
  scrolloff: 99999  // 既定の scrolloff
};
// （置換）Undo 定義ブロック（modifiedCount ～ doUndo まで）を Redo 対応版に差し替え
var modifiedCount = 0;           // 0 = クリーン (>0 = 変更あり)
var baselineText = '';           // 保存/読込直後の内容
var UNDO_MAX = 200;
var undoStack = [];
var redoStack = [];              // ★追加
var insertSessionActive = false;
function updateModifiedFlag(){
  window.modified = (modifiedCount > 0);
}
function setBaseline(text){
  baselineText = text;
  modifiedCount = 0;
  updateModifiedFlag();
  // ベースライン確定時は redo も破棄
  redoStack = [];
  // 既存 undoStack も初期化（呼び出し側で pushUndo('initial') する想定）
}
function pushUndo(reason){
  var ed = document.getElementById('editor');
  if(!ed) return;
  if (undoStack.length && undoStack[undoStack.length-1].text === ed.value) return;
  undoStack.push({
    text: ed.value,
    pos: getCaret(ed),
    reason: reason||'',
    mcount: modifiedCount
  });
  if (undoStack.length > UNDO_MAX) undoStack.shift();
  // 新しい編集開始で redo は失効
  if (redoStack.length) redoStack = [];
}
function doUndo(){
  var ed = document.getElementById('editor');
  if(!ed || !undoStack.length){
    if (typeof showMsg === 'function') showMsg('No undo', 800);
    return;
  }
  // 現在状態を redoStack に積む
  redoStack.push({
    text: ed.value,
    pos: getCaret(ed),
    mcount: modifiedCount
  });
  if (redoStack.length > UNDO_MAX) redoStack.shift();
  var snap = undoStack.pop();
  ed.value = snap.text;
  setCaret(ed, Math.min(snap.pos, ed.value.length));
  modifiedCount = snap.mcount || 0;
  if (ed.value === baselineText) modifiedCount = 0;
  updateModifiedFlag();
  insertSessionActive = false;
  if (typeof updateStatus==='function') updateStatus(ed);
  if (typeof ensureScrolloff==='function') ensureScrolloff(ed);
  if (typeof updateGutter==='function') updateGutter();
}
function doRedo(){
  var ed = document.getElementById('editor');
  if(!ed || !redoStack.length){
    if (typeof showMsg === 'function') showMsg('No redo', 800);
    return;
  }
  // 現在を undoStack に積む（戻れるように）
  undoStack.push({
    text: ed.value,
    pos: getCaret(ed),
    mcount: modifiedCount
  });
  if (undoStack.length > UNDO_MAX) undoStack.shift();
  var snap = redoStack.pop();
  ed.value = snap.text;
  setCaret(ed, Math.min(snap.pos, ed.value.length));
  modifiedCount = snap.mcount || 0;
  if (ed.value === baselineText) modifiedCount = 0;
  updateModifiedFlag();
  insertSessionActive = false;
  if (typeof updateStatus==='function') updateStatus(ed);
  if (typeof ensureScrolloff==='function') ensureScrolloff(ed);
  if (typeof updateGutter==='function') updateGutter();
}
// ====== 基本ユーティリティ ======
function _getSelStartEndIE(editor){
  try{
    if(!editor || !editor.createTextRange) return null;
    var sel = (document.selection && document.selection.createRange) ? document.selection.createRange() : null;
    if(!sel) return null;
    if (sel.parentElement && sel.parentElement() !== editor) return null;
    var r = editor.createTextRange();
    r.moveToElementText(editor);
    r.setEndPoint('EndToStart', sel);
    var start = r.text.length;
    var end   = start + sel.text.length;
    return { s:start, e:end };
  }catch(_){ return null; }
}
function getCaret(editor){
  try{
    if (editor && typeof editor.selectionStart === 'number'){
      if (typeof mode!=='undefined' && mode===MODE_VISUAL && editor.selectionStart!==editor.selectionEnd) return editor.selectionEnd;
      return editor.selectionStart;
    }
    var se = (typeof _getSelStartEndIE==='function') ? _getSelStartEndIE(editor) : null;
    if (se){
      if (typeof mode!=='undefined' && mode===MODE_VISUAL && se.s!==se.e) return se.e;
      return se.s;
    }
  }catch(_){ }
  return 0;
}
// VISUAL時は移動方向ごとに基準端を選ぶ（左/上=selectionStart、右/下=selectionEnd）
function getActivePosForDir(editor, dir){
  // VISUAL中は“アクティブ端”を優先（直前モーションで動いた側を基準にする）
  if (mode === MODE_VISUAL && editor.selectionStart !== editor.selectionEnd){
    if (visActiveEnd === 'start') return editor.selectionStart;
    if (visActiveEnd === 'end')   return editor.selectionEnd;
    // フォールバック（未設定時のみ方向で判定）
    return (dir === 'left' || dir === 'up') ? editor.selectionStart : editor.selectionEnd;
  }
  return getCaret(editor);
}
function setCaret(editor,pos){ pos=Math.max(0,Math.min((editor.value||'').length,pos|0));
  // TextRange を優先（IE/HTA 安定）
  if (editor && editor.createTextRange){
    try{ var r=editor.createTextRange(); r.collapse(true); r.move('character',pos|0); r.select(); }catch(_){ }
  } else if (editor && editor.setSelectionRange){
    try{ editor.setSelectionRange(pos,pos); }catch(_){ }
  }
  try{ window._lastSelStart=pos|0; window._lastSelEnd=pos|0; window._lastPos=pos|0; }catch(_){ }
  // 現在バッファへ常時同期（切替時の復元安定化）
  try{
    if (typeof Buffers==='object' && Buffers.current>=0){
      var __b = Buffers.list[Buffers.current];
      if (__b) { __b.pos=pos|0; __b.selStart=pos|0; __b.selEnd=pos|0; __b.scrollTop = editor.scrollTop|0; }
    }
  }catch(_){ }
}
function setSelection(editor,a,b){
  var s=(a|0), e=(b|0); if (e<s){ var t=s; s=e; e=t; }
  var len=(editor.value||'').length|0; s=Math.max(0,Math.min(len,s)); e=Math.max(0,Math.min(len,e));
  if (editor && editor.createTextRange){
    try{
      var r=editor.createTextRange(); r.collapse(true); r.moveStart('character', s); r.moveEnd('character', e-s); r.select();
    }catch(_){ }
  } else if (editor && editor.setSelectionRange){
    try{ editor.setSelectionRange(s,e); }catch(_){ }
  }
  try{ window._lastSelStart=s|0; window._lastSelEnd=e|0; window._lastPos=e|0; }catch(_){ }
  // 現在バッファへ常時同期（切替時の復元安定化）
  try{
    if (typeof Buffers==='object' && Buffers.current>=0){
      var __b = Buffers.list[Buffers.current];
      if (__b) { __b.pos=e|0; __b.selStart=s|0; __b.selEnd=e|0; __b.scrollTop = editor.scrollTop|0; }
    }
  }catch(_){ }
}
function lineStartIndex(text,pos){ return text.lastIndexOf('\n', Math.max(0,pos-1)) + 1; }
function lineEndIndex(text,pos){ var i=text.indexOf('\n', pos); return (i===-1)?text.length:i; }
function getLineCol(text,pos){ var s=lineStartIndex(text,pos); return { line: text.slice(0,pos).split('\n').length, col: pos - s + 1 }; }
function getLineHeightPx(editor){ var cs = window.getComputedStyle?getComputedStyle(editor):editor.currentStyle;
  var lh=parseFloat(cs.lineHeight); if(!lh||isNaN(lh)){ var fs=parseFloat(cs.fontSize)||21; lh=Math.round(fs*1.6); } return lh; }
function isSpace(ch){ return ch===' '||ch==='\t'||ch==='\u3000'; }
function firstNonBlankPos(text,pos){ var s=lineStartIndex(text,pos), e=lineEndIndex(text,pos), i=s; while(i<e && isSpace(text[i])) i++; return i; }
// 追加/置換: 行数関連ユーティリティ（末尾改行は余分に数えない）
function totalLines(text){
  if(!text || text.length===0) return 1;
  var nl=0;
  for(var i=0;i<text.length;i++){
    if(text.charCodeAt(i)===10) nl++;
  }
  return (text.charAt(text.length-1)==='\n') ? nl : nl+1;
}
function lineStartByNumber(text, ln){
  ln = ln|0;
  if (ln<=1) return 0;
  var cur=1, i=0, L=text.length;
  while(i<L && cur<ln){
    var j=text.indexOf('\n', i);
    if(j===-1) return L;
    i=j+1;
    // 末尾改行直後は空行として数えない（ln が行数上限を超えたら末尾へ）
    cur++;
  }
  return i;
}
function lineFirstNonBlankByNumber(text, ln){
  var s=lineStartByNumber(text, ln);
  var e=lineEndIndex(text,s);
  while(s<e && isSpace(text[s])) s++;
  return s;
}
/* PATCH:add-deleteRange */
// --- 追加: 削除ヘルパとレジスタ（既存が無ければ定義） ---
if (typeof setRegister !== 'function') {
  var _REG = { text: '', linewise: false };
  function setRegister(reg){ _REG = { text: String(reg && reg.text || ''), linewise: !!(reg && reg.linewise) }; }
  function getRegister(){ return { text: _REG.text, linewise: !!_REG.linewise }; }
}
if (typeof deleteRange !== 'function') {
  function deleteRange(editor, from, to, opts){
    try{ pushUndo('delete'); }catch(_){ }
    var v = editor.value || '';
    var L = v.length|0;
    from = Math.max(0, Math.min(L, from|0));
    to   = Math.max(0, Math.min(L, to|0));
    if (to < from){ var tmp=from; from=to; to=tmp; }
    var cut = v.slice(from, to);
    try{ if (typeof setRegister==='function'){ setRegister({ text: cut, linewise: !!(opts && opts.linewise) }); } }catch(_){ }
    editor.value = v.slice(0, from) + v.slice(to);
    try{ setCaret(editor, from); }catch(_){ }
    try{ modifiedCount++; updateModifiedFlag(); }catch(_){ }
    try{ updateStatus(editor); ensureScrolloff(editor); updateGutter(); }catch(_){ }
    try{ lastCmd='delete'; lastDeleteLinewise = !!(opts && opts.linewise); }catch(_){ }
  }
}
// 行番号ライン範囲削除ヘルパ : startLine, endLine を丸ごと削除
function deleteLineRange(editor, text, startLine, endLine){
  startLine = startLine|0; endLine = endLine|0;
  if (startLine < 1) startLine = 1;
  if (endLine < 1) endLine = 1;
  var fromLine = Math.min(startLine, endLine);
  var toLine   = Math.max(startLine, endLine);
  // 行開始位置
  var startIdx = lineStartByNumber(text, fromLine);
  var endLineStart = lineStartByNumber(text, toLine);
  var endIdx = lineEndIndex(text, endLineStart);
  // 末尾に改行があるなら含める（最終行でなければ +1）
  if (endIdx < text.length) endIdx = endIdx + 1;
  deleteRange(editor, startIdx, endIdx, { linewise: true });
}
// ==== 日本語対応の語移動ヘルパ ====
// サロゲートペア対応コードポイント処理
function _cpAt(str,i){ var hi=str.charCodeAt(i); if(hi>=0xD800&&hi<=0xDBFF&&i+1<str.length){ var lo=str.charCodeAt(i+1); if(lo>=0xDC00&&lo<=0xDFFF){ return (hi-0xD800)*0x400+(lo-0xDC00)+0x10000; } } return hi; }
function _nextIndex(str,i){ if(i>=str.length) return str.length; var hi=str.charCodeAt(i); if(hi>=0xD800&&hi<=0xDBFF&&i+1<str.length){ var lo=str.charCodeAt(i+1); if(lo>=0xDC00&&lo<=0xDFFF) return i+2; } return i+1; }
function _prevIndex(str,i){ if(i<=0) return 0; var lo=str.charCodeAt(i-1); if(lo>=0xDC00&&lo<=0xDFFF&&i-2>=0){ var hi=str.charCodeAt(i-2); if(hi>=0xD800&&hi<=0xDBFF) return i-2; } return i-1; }
// 語クラス判定
var _WT_SPACE=0,_WT_NL=1,_WT_ALNUM=2,_WT_KANA=3,_WT_HAN=4,_WT_SYMBOL=5;
function _isSpaceCp(cp){ return cp===0x20||cp===0x09||cp===0x3000; }
function _isNewlineCp(cp){ return cp===0x0A||cp===0x0D; }
function _isAsciiWordCp(cp){ return (cp>=0x30&&cp<=0x39)||(cp>=0x41&&cp<=0x5A)||(cp>=0x61&&cp<=0x7A)||cp===0x5F; }
function _isFullwidthAlnumCp(cp){ return (cp>=0xFF10&&cp<=0xFF19)||(cp>=0xFF21&&cp<=0xFF3A)||(cp>=0xFF41&&cp<=0xFF5A)||cp===0xFF3F; }
function _isKanaCp(cp){ return (cp>=0x3040&&cp<=0x309F)||(cp>=0x30A0&&cp<=0x30FF)||(cp>=0xFF66&&cp<=0xFF9D)||cp===0x30FC||cp===0x30FB; }
function _isHanCp(cp){ return (cp>=0x4E00&&cp<=0x9FFF)||(cp>=0x3400&&cp<=0x4DBF)||(cp>=0x20000&&cp<=0x2FA1F); }
function _wordTypeAt(str,i){
  if(i<0||i>=str.length) return _WT_SPACE;
  var cp=_cpAt(str,i);
  if(_isNewlineCp(cp)) return _WT_NL;
  if(_isSpaceCp(cp)) return _WT_SPACE;
  if(_isAsciiWordCp(cp)||_isFullwidthAlnumCp(cp)) return _WT_ALNUM;
  if(_isKanaCp(cp)) return _WT_KANA;
  if(_isHanCp(cp)) return _WT_HAN;
  return _WT_SYMBOL;
}
// b: 前の語頭へ（空白・改行を飛ばし、直前の語ブロックの先頭へ）
function wordLeftPos(text,pos){
  var i=pos;
  // 左側の空白/改行を飛ばす
  while(i>0){
    var pi=_prevIndex(text,i);
    var t=_wordTypeAt(text,pi);
    if(t!==_WT_SPACE && t!==_WT_NL) break;
    i=pi;
  }
  if(i<=0) return 0;
  // 直前位置の語タイプ
  var j=_prevIndex(text,i);
  var curT=_wordTypeAt(text,j);
  // その語ブロックの先頭へ
  while(j>0){
    var pj=_prevIndex(text,j);
    if(_wordTypeAt(text,pj)!==curT) break;
    j=pj;
  }
  return j;
}
// w: 次の語頭へ（現語ブロックの末尾→後続の空白/改行を飛ばして次の語頭）
function wordRightPos(text,pos){
  var n=text.length, i=pos;
  if(i>=n) return n;
  // 空白/改行の上ならまず飛ばす
  while(i<n){
    var t=_wordTypeAt(text,i);
    if(t!==_WT_SPACE && t!==_WT_NL) break;
    i=_nextIndex(text,i);
  }
  if(i>=n) return n;
  // 現在の語タイプの連続を抜ける
  var curT=_wordTypeAt(text,i);
  while(i<n && _wordTypeAt(text,i)===curT){
    i=_nextIndex(text,i);
  }
  // 次の語頭まで空白/改行を飛ばす
  while(i<n){
    var t2=_wordTypeAt(text,i);
    if(t2!==_WT_SPACE && t2!==_WT_NL) break;
    i=_nextIndex(text,i);
  }
  return i;
}
function posUp(text,pos,lines){
  lines=lines||1;
  var start=lineStartIndex(text,pos), col=pos-start, target=pos;
  for(var n=0;n<lines;n++){
    var prevEnd=start-1;
    if(prevEnd<0) break;
    var prevStart=lineStartIndex(text,prevEnd);
    var prevLen=prevEnd-prevStart;
    // VISUALモード時はanchorPosの列を維持できる範囲で移動
    if(mode===MODE_VISUAL && visualCol!==null){
      target=prevStart+Math.min(visualCol, prevLen);
    }else{
      target=prevStart+Math.min(col,prevLen);
    }
    start=prevStart;
  }
  return target;
}
function posDown(text,pos,lines){
  lines=lines||1;
  var start=lineStartIndex(text,pos), col=pos-start, target=pos;
  var nextStart=lineEndIndex(text,pos)+1;
  for(var n=0;n<lines;n++){
    if(nextStart<=0||nextStart>text.length) break;
    var nextEnd=lineEndIndex(text,nextStart);
    var nextLen=nextEnd-nextStart;
    // VISUALモード時はanchorPosの列を維持できる範囲で移動
    if(mode===MODE_VISUAL && visualCol!==null){
      target=nextStart+Math.min(visualCol, nextLen);
    }else{
      target=nextStart+Math.min(col,nextLen);
    }
    var afterNext=nextEnd+1;
    if(afterNext<=text.length) nextStart=afterNext; else break;
  }
  return target;
}
// 段落（空行区切り）
function isLineBlank(text, lineStart){ var end=lineEndIndex(text,lineStart); var s=text.slice(lineStart,end); return s.replace(/[ \t\u3000]/g,'').length===0; }
function paragraphPrev(text,pos){ var curStart=lineStartIndex(text,pos); var j=curStart-1;
  while(j>=0){ var ls=lineStartIndex(text,j); if(isLineBlank(text,ls)){ var nextStart=lineEndIndex(text,ls)+1; return firstNonBlankPos(text, Math.min(nextStart,text.length)); } j=ls-1; }
  return firstNonBlankPos(text,0); }
function paragraphNext(text,pos){ var i=lineEndIndex(text,pos)+1;
  while(i<=text.length){ if(i>=text.length){ var lastStart=text.lastIndexOf('\n')+1; return firstNonBlankPos(text,lastStart); }
    var ls=i, le=lineEndIndex(text,ls); if(isLineBlank(text,ls)){ var k=le+1; while(k<=text.length && isLineBlank(text,k)) k=lineEndIndex(text,k)+1;
      return firstNonBlankPos(text, Math.min(k,text.length)); } i=le+1; } return pos; }
// --- 最終行終端判定（Ctrl+N / w で末行から“下”に抜けるのを防止）---
if (typeof isAtLastLineCaret !== 'function') {
  function isAtLastLineCaret(text, pos){
    if (!text) return true;
    var tl = totalLines(text);
    var lc = getLineCol(text, pos).line;
    if (lc !== tl) return false;
    if (text.length === 0) return true;
    if (text.charAt(text.length-1) === '\n') {
      // 末尾改行あり: 改行文字（length-1）位置が最終行終端
      return pos >= text.length - 1;
    }
    // 末尾改行なし: EOF が終端
    return pos >= text.length;
  }
}
// （追加）isAtLastLineCaret の直後など、既存ユーティリティ付近に挿入
// --- 最終行判定（行番号のみで判定：末尾の位置に依らず最終行なら true）---
if (typeof isOnLastLine !== 'function') {
  function isOnLastLine(text, pos){
    if (!text) return true;
    return getLineCol(text, pos).line === totalLines(text);
  }
}
// ====== モード管理 ======
var MODE_NORMAL='NORMAL', MODE_INSERT='INSERT', MODE_VISUAL='VISUAL';
var mode = MODE_NORMAL, anchorPos=null, visualCol = null, opPending = null, lastMotionDir = null; // ←追加: 直前の移動方向を記憶
// 直前コマンドの種別と、直前削除が行単位だったかを記録（dd連打で追記するため）
var lastCmd = null, lastDeleteLinewise = false;
// 数値接頭辞バッファと演算子の繰り返し数（N d {motion} の N）
var countBuffer = '';
var opRepeat = 1;
// 追加: 'g' プレフィックス待機フラグ（gg 判定用）
var gPending = false;
// 追加: VISUAL選択の“アクティブ端”（直近モーションで動いた側）を保持
var visActiveEnd = null;
/* PATCH:buffers */
// === Buffer manager (Vim-like) ===
var Buffers = { list: [], current: -1, prev: -1, nextId: 1 };
function _bufMakeName(path){ return path ? String(path).replace(/^.*[\\\/]/,'') : '[No Name]'; }
function _bufFindById(id){ id=+id; for(var i=0;i<Buffers.list.length;i++){ if(Buffers.list[i].id===id) return i; } return -1; }
function _bufFindByPath(path){ for(var i=0;i<Buffers.list.length;i++){ if(Buffers.list[i].path===path) return i; } return -1; }
function _bufMatches(spec, b){ var s=String(spec||'').toLowerCase(); var name=_bufMakeName(b.path).toLowerCase(); var p=String(b.path||'').toLowerCase(); return (name.indexOf(s)===0)||(p.indexOf(s)===0); }
function bufFindBySpec(spec){
  if(spec==='#' && Buffers.prev>=0) return Buffers.prev;
  if(/^\d+$/.test(spec)) return _bufFindById(parseInt(spec,10));
  var hits=[],i; for(i=0;i<Buffers.list.length;i++){ if(_bufMatches(spec, Buffers.list[i])) hits.push(i); }
  if(hits.length===1) return hits[0];
  return (hits.length===0)?-1:{ ambiguous:true, hits:hits };
}
function bufCaptureFromEditor(){
  var ed=document.getElementById('editor'); if(!ed) return; var idx=Buffers.current; if(idx<0) return;
  var b=Buffers.list[idx];
  // cmdline 表示中や editor が非アクティブのときは DOM/IE の selection を使わず、最後に確定した値を優先
  var cmd=document.getElementById('cmdline');
  var cmdShown = !!(cmd && (cmd.style.display==='inline-block' || cmd.style.display==='block'));
  var active = (document.activeElement === ed);
  // 非フォーカス時は DOM/IE 取得を無効化して _last* にフォールバック
  var sDom = (!cmdShown && active && typeof ed.selectionStart==='number') ? ed.selectionStart : null;
  var eDom = (!cmdShown && active && typeof ed.selectionEnd  ==='number') ? ed.selectionEnd   : null;
  var se   = (!cmdShown && active && typeof _getSelStartEndIE==='function') ? _getSelStartEndIE(ed) : null;
  var sIE  = se ? se.s : null;
  var eIE  = se ? se.e : null;
  var sLast= (typeof window._lastSelStart==='number') ? window._lastSelStart : null;
  var eLast= (typeof window._lastSelEnd  ==='number') ? window._lastSelEnd   : null;
  var pLast= (typeof window._lastPos     ==='number') ? window._lastPos      : null;
  b.text = ed.value;
  var Lv = b.text.length|0;
  var s = (sDom!=null)?sDom : (sIE!=null)?sIE : (sLast!=null)?sLast : 0;
  var e = (eDom!=null)?eDom : (eIE!=null)?eIE : (eLast!=null)?eLast : s;
  if (s<0) s=0; if (e<0) e=0; if (s>Lv) s=Lv; if (e>Lv) e=Lv;
  b.selStart = s|0; b.selEnd = e|0;
  var p = (eDom!=null)?eDom : (eIE!=null)?eIE : (pLast!=null)?pLast : e;
  if (p<0) p=0; if (p>Lv) p=Lv; b.pos = p|0;
  b.scrollTop = ed.scrollTop|0;
  b.modifiedCount = modifiedCount|0;
  b.baselineText  = baselineText||'';
  b.undoStack = (undoStack||[]).slice(0);
  b.redoStack = (redoStack||[]).slice(0);
  b.insertSessionActive = !!insertSessionActive;
  b.path = window._currentFile||b.path||'';
}
function bufApplyToEditor(idx){
  var ed=document.getElementById('editor'); if(!ed) return; var b=Buffers.list[idx]||{};
  ed.value = String(b.text||'');
  window._currentFile = b.path||'';
  var L = ed.value.length|0;
  var caret = (typeof b.pos==='number') ? (b.pos|0)
            : (typeof b.selEnd==='number') ? (b.selEnd|0)
            : (typeof b.selStart==='number') ? (b.selStart|0)
            : 0;
  var s = (typeof b.selStart==='number') ? (b.selStart|0) : caret;
  var e = (typeof b.selEnd  ==='number') ? (b.selEnd  |0) : s;
  if (s<0) s=0; if (e<0) e=0; if (s>L) s=L; if (e>L) e=L;
  // 先にスクロール位置を復元（描画前）
  ed.scrollTop = (typeof b.scrollTop==='number') ? (b.scrollTop|0) : 0;
  // 状態系
  baselineText = b.baselineText||'';
  modifiedCount = b.modifiedCount|0;
  undoStack = (b.undoStack||[]).slice(0);
  redoStack = (b.redoStack||[]).slice(0);
  insertSessionActive = !!b.insertSessionActive;
  // カーソル/選択の復元
  try{ ed.focus(); }catch(_){ }
  if (s!==e){ setSelection(ed, s, e); } else { setCaret(ed, s); }
  if (typeof updateStatus==='function') updateStatus(ed);
  try{ window._suppressScrolloffOnce = false; }catch(_){ }
  if (typeof ensureScrolloff==='function') ensureScrolloff(ed);
  if (typeof updateGutter==='function') updateGutter();
  // 遅延で選択とスクロールをもう一度確定（他処理の上書きを抑止）
  try{
    (function(ss,ee,cp,st){
      function applyOnce(){
        var ed2=document.getElementById('editor'); if(!ed2) return;
        try{ ed2.focus(); }catch(_){ }
        if (ss!==ee){ setSelection(ed2, ss, ee); } else { setCaret(ed2, ss); }
        if (typeof st==='number') ed2.scrollTop = st|0;
        if (typeof updateStatus==='function') updateStatus(ed2);
        try{ window._suppressScrolloffOnce = false; }catch(_){ }
        if (typeof ensureScrolloff==='function') ensureScrolloff(ed2);
      }
      setTimeout(applyOnce, 0);
      setTimeout(applyOnce, 40);
    })(s,e,caret, (typeof b.scrollTop==='number')?(b.scrollTop|0):0);
  }catch(_){ }
}
/* caret-helper-injected */
function reapplyCaretDeferred(ss, ee, cp){
  try{ window._pendingSel = { s:(ss|0), e:(ee|0), cp:(cp|0) }; }catch(_){ }
  function applyOnce(){
    try{
      var ed2=document.getElementById('editor'); if(!ed2) return;
      var LL=ed2.value.length|0;
      var S=Math.max(0, Math.min(LL, ss|0));
      var E=Math.max(0, Math.min(LL, ee|0));
      try{ ed2.focus(); }catch(_){ }
      if (S!==E){ if (ed2.setSelectionRange) ed2.setSelectionRange(S,E); else if (typeof setSelection==='function') setSelection(ed2,S,E); }
      else { if (typeof setCaret==='function') setCaret(ed2, S); }
      if (typeof updateStatus==='function') updateStatus(ed2);
    }catch(_){ }
  }
  setTimeout(applyOnce, 0);
  setTimeout(applyOnce, 30);
  setTimeout(applyOnce, 80);
}
function bufCreate(opts){
  var b={ id:Buffers.nextId++, path:(opts&&opts.path)||'', text:(opts&&typeof opts.text==='string')?opts.text:'', pos:0, scrollTop:0,
    modifiedCount:0, baselineText:(opts&&opts.text)||'', undoStack:[], redoStack:[], insertSessionActive:false };
  Buffers.list.push(b);
  var __idx = Buffers.list.length-1;
  try{ if (opts && opts.dispName){ Buffers.list[__idx].dispName = String(opts.dispName); } }catch(_){ }
  return __idx;
}
function bufSwitchToIndex(newIdx){
  if(newIdx<0||newIdx>=Buffers.list.length) return; if(Buffers.current===newIdx){ updateStatus(document.getElementById('editor')); return; }
  if (Buffers.current>=0) {
    try{
      var __ed = document.getElementById('editor');
      var __cmd = document.getElementById('cmdline');
      var __shown  = !!(__cmd && (__cmd.style.display==='inline-block' || __cmd.style.display==='block'));
      var __active = (document.activeElement === __ed);
      if (__ed && __active && !__shown){
        try{
          var __bcur=(typeof Buffers==='object'&&Buffers.current>=0)?Buffers.list[Buffers.current]:null;
          var __p=(typeof window._lastPos==='number')?window._lastPos:(__bcur&&typeof __bcur.pos==='number'?__bcur.pos:null);
          if(__ed && __p!=null){
            var __L=__ed.value.length|0; var __P=Math.max(0,Math.min(__L,__p|0));
            if(__ed.setSelectionRange) __ed.setSelectionRange(__P,__P); else if (typeof setCaret==='function') setCaret(__ed,__P);
          }
        }catch(_){ }
        if (typeof updateStatus==='function') updateStatus(__ed);
        bufCaptureFromEditor();
      } // それ以外は直近同期値を信頼し保存スキップ
    }catch(_){ }
  }
  Buffers.prev=Buffers.current; Buffers.current=newIdx; bufApplyToEditor(newIdx);
  try{ window._suppressScrolloffOnce = false; }catch(_){ }
  // __reapply_after_switch__: 遅延でカーソル/選択を再適用して他処理の上書きを無効化
  // __reapply_after_switch__: 遅延でカーソル/選択を再適用して他処理の上書きを無効化
  try{
    (function(b){
      var ss = (typeof b.selStart==='number') ? (b.selStart|0) : ((typeof b.pos==='number')?(b.pos|0):0);
      var ee = (typeof b.selEnd  ==='number') ? (b.selEnd  |0) : ((typeof b.pos==='number')?(b.pos|0):0);
      var cp = (typeof b.pos     ==='number') ? (b.pos     |0) : 0;
      function applyOnce(){
        try{
          var ed=document.getElementById('editor'); if(!ed) return;
          try{ ed.focus(); }catch(_){ }
          if (ss!==ee){ if (typeof setSelection==='function') setSelection(ed, ss, ee); else if (ed.setSelectionRange) ed.setSelectionRange(ss,ee); }
          else { if (typeof setCaret==='function') setCaret(ed, ss); else if (ed.setSelectionRange) ed.setSelectionRange(ss,ss); }
          if (typeof updateStatus==='function') updateStatus(ed);
          if (typeof b.scrollTop==='number') ed.scrollTop = b.scrollTop|0;
          try{ window._suppressScrolloffOnce = false; }catch(_){ }
          if (typeof ensureScrolloff==='function') ensureScrolloff(ed);
        }catch(_){ }
      }
      setTimeout(applyOnce, 0);
      setTimeout(applyOnce, 30);
      setTimeout(applyOnce, 80);
    })(Buffers.list[newIdx]||{});
  }catch(_){ }
  try{ showMsg('Buffer '+Buffers.list[newIdx].id+': '+_bufMakeName(Buffers.list[newIdx].path), 900); }catch(_){ }
}
function bufListString(){
  var out=[],i; for(i=0;i<Buffers.list.length;i++){
    var b=Buffers.list[i], cur=(i===Buffers.current)?'% ':'  ';
    out.push(cur+' '+b.id+' '+_bufMakeName(b.path)+(b.path?(' ('+b.path+')'):'')+(b.modifiedCount>0?' [+]':''));
  } return out.join(' | ');
}
function bufEnsureInitial(){
  if(Buffers.list.length) return; var ed=document.getElementById('editor'); var idx=bufCreate({ path: window._currentFile||'', text: (ed&&ed.value)||'' }); Buffers.current=idx; bufApplyToEditor(idx);
}
function bufOpenFile(path, forceReload){
  try{
    var ed=document.getElementById('editor'); var fsoOk=true; try{ new ActiveXObject('Scripting.FileSystemObject'); }catch(_){ fsoOk=false; }
    if(!fsoOk){ showMsg('File I/O not available',1500); return; }
    var fso=new ActiveXObject('Scripting.FileSystemObject'); var exists=fso.FileExists(path); var idx=_bufFindByPath(path);
    if(idx>=0){
      if(forceReload && exists){
        var st=new ActiveXObject('ADODB.Stream'); st.Type=2; st.Charset='UTF-8'; st.Open(); st.LoadFromFile(path); var content=st.ReadText(); st.Close();
        content = content.replace(/\r\n?/g, '\n');
        var b=Buffers.list[idx]; b.text=content; b.baselineText=content; b.modifiedCount=0; b.undoStack=[]; b.redoStack=[]; b.insertSessionActive=false; b.pos=0; b.scrollTop=0;
      }
      bufSwitchToIndex(idx); return;
    }
    // reuse current [No Name] buffer if clean (no edits)
    var text=''; if(exists){ var st2=new ActiveXObject('ADODB.Stream'); st2.Type=2; st2.Charset='UTF-8'; st2.Open(); st2.LoadFromFile(path); text=st2.ReadText(); st2.Close(); }
    if (Buffers.current>=0){
      var bcur = Buffers.list[Buffers.current];
      if ((bcur.path||'')==='' && (bcur.modifiedCount|0)===0){
        bcur.path = path; bcur.text = text; bcur.baselineText = text; bcur.modifiedCount = 0;
        bcur.undoStack = []; bcur.redoStack = []; bcur.insertSessionActive=false; bcur.pos=0; bcur.scrollTop=0;
        bufApplyToEditor(Buffers.current);
        try{ showMsg('Buffer '+bcur.id+': '+_bufMakeName(bcur.path), 900); }catch(_){ }
        return;
      }
    }
    // otherwise create a new buffer
    var newIdx=bufCreate({ path:path, text:text }); bufSwitchToIndex(newIdx);
  }catch(e){ try{ showMsg('Open failed',1500); }catch(_){ } }
}
function setMode(newMode, editor){
  var prev = mode;
  mode=newMode;
  document.getElementById('mode').innerText='['+mode+']';
  if(mode===MODE_INSERT){
    if(!insertSessionActive){
      pushUndo('insert-begin');
      insertSessionActive = true;
    }
    anchorPos=null; visualCol=null; opPending=null; lastMotionDir=null; visActiveEnd=null;
    countBuffer=''; opRepeat=1;
  }else if(mode===MODE_VISUAL){
    anchorPos=getCaret(editor);
    visualCol = getLineCol(editor.value, anchorPos).col - 1;
    setSelection(editor,anchorPos,anchorPos);
    lastMotionDir=null; visActiveEnd=null;
    countBuffer=''; opRepeat=1;
    if(prev===MODE_INSERT) insertSessionActive=false;
  }else{ // NORMAL
    anchorPos=null; visualCol=null; opPending=null; lastMotionDir=null; visActiveEnd=null;
    countBuffer=''; opRepeat=1;
    if(editor && editor.selectionStart!==editor.selectionEnd){
      setCaret(editor, editor.selectionEnd);
    }
    if(prev===MODE_INSERT) insertSessionActive=false;
  }
  lastCmd='other';
  updateStatus(editor); ensureScrolloff(editor);
}
function posUp(text,pos,lines){
  lines=lines||1;
  var start=lineStartIndex(text,pos), col=pos-start, target=pos;
  for(var n=0;n<lines;n++){
    var prevEnd=start-1;
    if(prevEnd<0) break;
    var prevStart=lineStartIndex(text,prevEnd);
    var prevLen=prevEnd-prevStart;
    // VISUALモード時はanchorPosの列を維持できる範囲で移動
    if(mode===MODE_VISUAL && visualCol!==null){
      target=prevStart+Math.min(visualCol, prevLen);
    }else{
      target=prevStart+Math.min(col,prevLen);
    }
    start=prevStart;
  }
  return target;
}
function posDown(text,pos,lines){
  lines=lines||1;
  var start=lineStartIndex(text,pos), col=pos-start, target=pos;
  var nextStart=lineEndIndex(text,pos)+1;
  for(var n=0;n<lines;n++){
    if(nextStart<=0||nextStart>text.length) break;
    var nextEnd=lineEndIndex(text,nextStart);
    var nextLen=nextEnd-nextStart;
    // VISUALモード時はanchorPosの列を維持できる範囲で移動
    if(mode===MODE_VISUAL && visualCol!==null){
      target=nextStart+Math.min(visualCol, nextLen);
    }else{
      target=nextStart+Math.min(col,nextLen);
    }
    var afterNext=nextEnd+1;
    if(afterNext<=text.length) nextStart=afterNext; else break;
  }
  return target;
}
// === 検索状態とヘルパ ===
var searchState = { pat: '', dir: 1 }; // dir: 1=forward, -1=backward
function doSearch(pattern, dir, fromPos, opts){
  try{
    var ed = document.getElementById('editor');
    if (!ed){ return; }
    var text = ed.value;
    var n = text.length;
    if (!pattern){ showMsg('No search pattern', 1200); return; }
    // 基準方向更新（/:? 確定時のみ）
    if (opts && opts.updateBase){
      searchState.dir = (dir >= 0) ? 1 : -1;
    }
    searchState.pat = pattern;
    var inclusive = !!(opts && opts.inclusive);
    var pos = (typeof fromPos === 'number') ? fromPos : getCaret(ed);
    // 検索前スクロール位置（可視内ヒット時の自動スクロール打消しに使用）
    var prevST = (typeof window._searchFromScrollTop === 'number') ? window._searchFromScrollTop : ed.scrollTop;
    var idx = -1;
    if (dir >= 0){
      var start = inclusive ? pos : Math.min(n, pos + 1);
      if (start < 0) start = 0;
      if (start > n) start = n;
      idx = text.indexOf(pattern, start);
      if (idx < 0) idx = text.indexOf(pattern, 0); // wrap
    }else{
      var startB = inclusive ? pos : Math.max(0, pos - 1);
      if (startB < 0) startB = 0;
      if (startB > n) startB = n;
      idx = text.lastIndexOf(pattern, startB);
      if (idx < 0) idx = text.lastIndexOf(pattern); // wrap
    }
    if (idx >= 0){
      var end = idx + pattern.length;
      setSelection(ed, idx, end);
      setCaret(ed, idx);
      updateStatus(ed);
    // PATCH: 検索ヒット時にもスクロール余白/センタリングを反映
    try { lastMotionDir = (dir >= 0) ? down : up; } catch(_) {}
    try { ensureScrolloff(ed); } catch(_) {}
      try{ window._incLastMiss=false; window._incLastHit=true; window._incLastIdx=idx; }catch(_){ }
      // incsearch プレビュー（未確定時のハイライトとスクロール抑制）
      if (opts && opts.incPreview){
        try{
          var lc = getLineCol(text, idx);
          renderIncPreviewRange(lc.line, lc.col, pattern.length);
          var lh = getLineHeightPx(ed);
          if (lh && isFinite(lh) && lh > 0){
            var STATUSBAR_H = 28;
            var visibleH = ed.clientHeight - STATUSBAR_H;
            if (visibleH < lh) visibleH = lh;
            // 検索開始時のスクロール基準で可視範囲判定
            var startLine = Math.floor(prevST / lh) + 1;
            var visLines  = Math.max(1, Math.ceil(visibleH / lh));
            var endLine   = startLine + visLines - 1;
            var hitLine   = getLineCol(text, idx).line;
            var withinView = (hitLine >= startLine && hitLine <= endLine);
            if (withinView){
              ed.scrollTop = prevST;     // 自動スクロールを打消し
            }else{
              ensureScrolloff(ed);       // 画面外ヒットのみ通常調整
            }
          }
        }catch(_){}
      }else{
        ensureScrolloff(ed);
      }
      return;
    }
    // 未ヒット: incsearch 中は静かに終了（復帰してメッセージ抑止）
    if (opts && opts.incPreview){
      try{ window._incLastMiss = true; }catch(_){}
      try{ window._incLastIdx = undefined; }catch(_){ }
      try{ window._incLastHit=false; }catch(_){ }
      try{ clearIncPreview(); }catch(_){}
      try{
        if (typeof window._searchFromPos === 'number'){
          var L = ed.value.length;
          setCaret(ed, Math.max(0, Math.min(L, window._searchFromPos)));
          updateStatus(ed);
        }
        if (typeof window._searchFromScrollTop === 'number'){
          ed.scrollTop = window._searchFromScrollTop;
        }
      }catch(_){}
      return;
    }
    // 通常検索（確定）時のみメッセージ表示
    showMsg('Pattern not found: ' + pattern, 1400);
  }catch(_){}
}
// 貼り付け実装
function pasteInsert(editor, insPos, t){
  pushUndo('paste');
  var v = editor.value;
  editor.value = v.slice(0, insPos) + t + v.slice(insPos);
  setCaret(editor, insPos + t.length);
  modifiedCount++; updateModifiedFlag();
  updateStatus(editor); ensureScrolloff(editor); updateGutter();
  try{ ensureWindowResizer(); }catch(_){ }
  // 貼り付けでチェーンを切る
  lastCmd = 'other';
}
function pasteAfter(editor){
  var reg = getRegister();
  var v = editor.value;
  var s = editor.selectionStart, en = editor.selectionEnd;
  var pos = getCaret(editor);
  // VISUAL中は選択置換
  if (mode === MODE_VISUAL && s !== en){
    editor.value = v.slice(0, s) + v.slice(en);
    pos = s; v = editor.value;
  }
  if (reg.linewise){
    var le = lineEndIndex(v, pos);
    var ins = (le < v.length) ? le + 1 : v.length; // 次行頭 or EOF
    pasteInsert(editor, ins, reg.text);
  }else{
    var ins = Math.min(v.length, pos + (mode===MODE_VISUAL ? 0 : 1)); // NORMALは“後”、VISUAL置換後はその位置
    pasteInsert(editor, ins, reg.text);
  }
}
function pasteBefore(editor){
  var reg = getRegister();
  var v = editor.value;
  var s = editor.selectionStart, en = editor.selectionEnd;
  var pos = getCaret(editor);
  // VISUAL中は選択置換
  if (mode === MODE_VISUAL && s !== en){
    editor.value = v.slice(0, s) + v.slice(en);
    pos = s; v = editor.value;
  }
  if (reg.linewise){
    var ls = lineStartIndex(v, pos);
    pasteInsert(editor, ls, reg.text);
  }else{
    var ins = pos; // “前”
    pasteInsert(editor, ins, reg.text);
  }
}
function openLineBelow(editor){
  var v = editor.value;
  var pos = getCaret(editor);
  setMode(MODE_INSERT, editor);
  var le = lineEndIndex(v, pos);
  var ins = (le < v.length) ? le + 1 : v.length;
  editor.value = v.slice(0, ins) + '\n' + v.slice(ins);
  setCaret(editor, ins);
  try{ modifiedCount++; updateModifiedFlag(); }catch(_){ }
  try{ updateStatus(editor); ensureScrolloff(editor); updateGutter(); }catch(_){ }
}
function openLineAbove(editor){
  var v = editor.value;
  var pos = getCaret(editor);
  setMode(MODE_INSERT, editor);
  var ls = lineStartIndex(v, pos);
  editor.value = v.slice(0, ls) + '\n' + v.slice(ls);
  setCaret(editor, ls);
  try{ modifiedCount++; updateModifiedFlag(); }catch(_){ }
  try{ updateStatus(editor); ensureScrolloff(editor); updateGutter(); }catch(_){ }
}
// ====== ステータス・メッセージ・ヘルプ ======
function updateStatus(editor){
  var start=editor.selectionStart!=null?editor.selectionStart:getCaret(editor);
  var end=editor.selectionEnd!=null?editor.selectionEnd:start;
  var caret=end; var lc=getLineCol(editor.value,caret); var sel=Math.abs(end-start);
  var info='Ln '+lc.line+', Col '+lc.col; if(sel>0) info+=' (Sel '+sel+')';
  document.getElementById('pos').innerText=info;
  // 変更: ヘルプ案内をボタン化（クリックでヘルプ表示＋本文へフォーカス）
  document.getElementById('hint').innerHTML =
    '<button type="button" style="font-size:12px;padding:2px 8px;background:#2b2d31;color:#ddd;border:1px solid #3b3d42;border-radius:4px;cursor:pointer;" '+
    'title="F1 または :help" onclick="showHelp();var sc=document.getElementById(\'helpScroll\');if(sc)sc.focus();return false;">ヘルプ: F1/:help</button>';
  var filename = window._currentFile || '[No Name]';
  var bprefix = '';
  try{ if (typeof Buffers==='object' && Buffers.current>=0){ bprefix = '[' + Buffers.list[Buffers.current].id + '] '; } }catch(_){ }
  var modmark = (modifiedCount > 0) ? '[+]' : '';
  document.getElementById('filename').innerText = bprefix + filename;
  document.getElementById('modmark').innerText = modmark;
  document.getElementById('mode').innerText = '['+mode+']';
  // __bufsync__: updateStatus 実行ごとに現在バッファへカーソル/選択/スクロールを同期
  try{
    var ed2 = editor || document.getElementById('editor');
    if (ed2 && typeof Buffers==='object' && Buffers.current>=0){
      var b = Buffers.list[Buffers.current];
      // safer sync: cmdline表示中やeditor非アクティブ時はpos/selを同期しない（0上書き防止）
      var cmd=document.getElementById('cmdline');
      var __shown = !!(cmd && (cmd.style.display==='inline-block' || cmd.style.display==='block'));
      var __active = (document.activeElement === ed2);
      var __s = null, __e = null;
      if (!__shown && __active){
        if (typeof ed2.selectionStart==='number'){
          __s = ed2.selectionStart;
          __e = (typeof ed2.selectionEnd==='number') ? ed2.selectionEnd : __s;
        } else {
          var __se = (typeof _getSelStartEndIE==='function') ? _getSelStartEndIE(ed2) : null;
          if (__se){ __s = __se.s; __e = __se.e; }
        }
      }
      if (__s!=null && __e!=null){
        b.pos = __e; b.selStart = __s; b.selEnd = __e;
        try{ window._lastSelStart = __s|0; window._lastSelEnd = __e|0; window._lastPos = __e|0; }catch(_){ }
      }
      b.scrollTop = ed2.scrollTop|0;
    }
  }catch(_){ }
}
function showMsg(text, hold){
  var cmdmsg = document.getElementById('cmdmsg');
  cmdmsg.innerText = text;
  cmdmsg.style.display = 'block';
  showMsg._hold = !!hold;
  setTimeout(function(){ var c=document.getElementById('cmdline'); if(c){ var d=c.style.display||''; if(d==='inline-block'||d==='block') return; } var ed=document.getElementById('editor'); if(ed) ed.focus(); }, 0);
  if (!hold) {
    clearTimeout(showMsg._t);
    showMsg._t = setTimeout(function(){
      cmdmsg.style.display = 'none';
      showMsg._hold = false;
    }, 1200);
  }
}
// --- 追加: 一時メッセージ（キー入力または時間で自動消去） ---
function showMsgAuto(text, ms){
  try{ showMsg(text, true); }catch(_){ }
  var done=false;
  function clearAll(){
    if (done) return; done=true;
    try{ hideMsg(); }catch(_){ }
    try{ window.removeEventListener("keydown", onKey, true); }catch(_){ }
    try{ document.removeEventListener("keydown", onKey, true); }catch(_){ }
    try{ if (document.body) document.body.removeEventListener("keydown", onKey, true); }catch(_){ }
  }
  function onKey(e){ clearAll(); }
  try{ window.addEventListener("keydown", onKey, true); }catch(_){ }
  try{ document.addEventListener("keydown", onKey, true); }catch(_){ }
  try{ if (document.body) document.body.addEventListener("keydown", onKey, true); }catch(_){ }
  var t = (ms && ms>0) ? ms : 1500;
  setTimeout(clearAll, t);
}
function hideMsg(){
  var cmdmsg = document.getElementById('cmdmsg');
  cmdmsg.innerText = '';
  cmdmsg.style.display = 'none';
  showMsg._hold = false;
}
function showHelp(){
  var h = document.getElementById('help');
  h.style.display = 'block';
  // ヘルプにフォーカス（カーソルは表示されない）
  var sc = document.getElementById('helpScroll');
  if (sc) {
    sc.focus();
  }
}
function hideHelp(){
  document.getElementById('help').style.display='none';
  hideMsg();
}
function toggleHelp(){ var h=document.getElementById('help'); h.style.display = (h.style.display==='block'?'none':'block'); }
// === ヘルプ用キーバインド（j/k/↓/↑/gg/G/ESC のみ受け付け） ===
(function bindHelpKeys(){
    var help = document.getElementById('help');
    var sc = document.getElementById('helpScroll');
    if (!help || !sc) return;
    var helpGPending = false; // gg 判定
    function helpLineHeight(){
      var cs = window.getComputedStyle ? getComputedStyle(help) : help.currentStyle;
      var lh = parseFloat(cs.lineHeight);
      if (!lh || isNaN(lh)) {
        var fs = parseFloat(cs.fontSize) || 14;
        lh = Math.round(fs * 1.6);
      }
      return lh;
    }
    function handleHelpKey(e){
      if (help.style.display !== 'block') return;
      var k = e.key || '';
      var kc = e.keyCode || 0;
      var lh = helpLineHeight();
      var handled = true;
      // ESC → ヘルプを閉じてエディタへ
      if (k === 'Escape' || kc === 27){
        hideHelp();
        var ed = document.getElementById('editor');
        if (ed) ed.focus();
        helpGPending = false;
      }
      // j / ↓ → 下へスクロール
      else if (k === 'j' || k === 'J' || k === 'ArrowDown' || kc === 40){
        sc.scrollTop = Math.min(sc.scrollTop + lh, sc.scrollHeight);
        helpGPending = false;
      }
      // k / ↑ → 上へスクロール
      else if (k === 'k' || k === 'K' || k === 'ArrowUp' || kc === 38){
        sc.scrollTop = Math.max(0, sc.scrollTop - lh);
        helpGPending = false;
      }
      // 追加: Space / Shift+Space → 下/上スクロール
      else if ((k === ' ' || kc === 32) && !e.shiftKey){
        sc.scrollTop = Math.min(sc.scrollTop + lh, sc.scrollHeight);
        helpGPending = false;
      }
      else if ((k === ' ' || kc === 32) && e.shiftKey){
        sc.scrollTop = Math.max(0, sc.scrollTop - lh);
        helpGPending = false;
      }
      // gg / G
      else if (k === 'g' || k === 'G' || kc === 71){
        var isUpperG = (k === 'G') || (kc === 71 && e.shiftKey);
        if (isUpperG){
          sc.scrollTop = sc.scrollHeight;
          helpGPending = false;
        } else {
          if (helpGPending){
            sc.scrollTop = 0;
            helpGPending = false;
          } else {
            helpGPending = true;
            setTimeout(function(){ helpGPending = false; }, 800);
          }
        }
      }
      // 追加: F1 / q でも閉じる（隠し機能）
      else if (k === 'F1' || kc === 112 || k === 'q' || k === 'Q'){
        hideHelp();
        var ed2 = document.getElementById('editor');
        if (ed2) ed2.focus();
        helpGPending = false;
      }
      else {
        handled = true;
      }
      if (handled){
        e.preventDefault();
        e.stopPropagation();
        if (e.stopImmediatePropagation) e.stopImmediatePropagation();
      }
    }
    // ヘルプ自体とスクロール領域の両方で捕捉（フォーカス漏れ対策）
    help.addEventListener('keydown', handleHelpKey, true);
    sc.addEventListener('keydown', handleHelpKey, true);
  })();
// ====== ガター ======
function updateGutter() {
  var gutter = document.getElementById('gutter');
  var editor = document.getElementById('editor');
  var stripe = document.getElementById('edstripe');
  if (!OPT.number) {
    gutter.style.display='none';
    editor.style.paddingLeft='10px';
    if (stripe) stripe.style.display='none';
    return;
  }
  gutter.style.display='block';
  editor.style.paddingLeft='82px';
  var text = editor.value;
  var total = totalLines(text);
  var lh = getLineHeightPx(editor);
  // 小数pxを維持してテキストと完全一致させる
  var lhExact = (lh && isFinite(lh) && lh > 0) ? lh : 16;
  // エディタの上パディングをガターにも適用（基準位置を揃える）
  var padTop = 0; try{ var cs = window.getComputedStyle?getComputedStyle(editor):editor.currentStyle; padTop = parseFloat(cs.paddingTop)||0; }catch(_){ }
  gutter.style.paddingTop = (padTop|0) + 'px';
  // 本文/ガター両方の行高を明示指定（px, 小数可）
  try{ editor.style.lineHeight = lhExact + 'px'; }catch(_){ }
  gutter.style.lineHeight = lhExact + 'px';
  // ステータスバー高さ差し引き
  var STATUSBAR_H = (function(){ var cb=document.getElementById('cmdbar'); return cb && cb.offsetHeight ? cb.offsetHeight|0 : 28; })();
  var effHeight = editor.clientHeight - STATUSBAR_H;
  if (effHeight < lhExact) effHeight = lhExact;
  var startLine = Math.floor(editor.scrollTop / lhExact);
  var visible = Math.ceil(effHeight / lhExact) + 1;
  var endLine = Math.min(total, startLine + visible);
  var html = [];
  for (var ln = startLine + 1; ln <= endLine; ln++) {
    var isEven = (ln % 2 === 0);
    var bg = isEven ? 'background:darkSlateGray;' : '';
    html.push('<div class="ln" style="height:'+lhExact+'px;line-height:'+lhExact+'px;'+bg+'">' + ln + '</div>');
  }
  gutter.innerHTML = html.join('');
  // スクロール端数のみ逆方向に移動（基準は padding-top 同期済み）
  var offset = -(editor.scrollTop % lhExact);
  gutter.style.transform = 'translateY(' + (offset) + 'px)';
  // 本文側の偶数行ストライプをオーバーレイで可視化
  if (stripe){
    stripe.style.display='block';
    var padLeft = 82; // number=on 左パディング
    try{ var cs2 = window.getComputedStyle?getComputedStyle(editor):editor.currentStyle; padLeft = parseFloat(cs2.paddingLeft)||82; }catch(_){ }
    stripe.style.left = '0px';
    stripe.style.right = '0px';
    stripe.style.top = '0px';
    stripe.style.bottom = '0px';
    // ガターを除いた本文領域だけにストライプを出したいが、簡便に全体でOK
    var color = 'darkSlateGray';
    var size = lhExact*2; // 2行で1周期
    var bg = 'repeating-linear-gradient( to bottom, transparent 0px, transparent '+lhExact+'px, '+color+' '+lhExact+'px, '+color+' '+(lhExact*2)+'px )';
    stripe.style.backgroundImage = bg;
    stripe.style.backgroundSize = 'auto '+(size)+'px';
    stripe.style.backgroundPositionY = ((padTop - (editor.scrollTop % (lhExact*2)))) + 'px';
  }
}
// ====== scrolloff（表示端からの余白スクロール） ======
/* PATCH:getScrolloff */
function getScrolloff(){
  try{
    var n = (typeof OPT==='object' && typeof OPT.scrolloff==='number') ? (OPT.scrolloff|0) : 3;
    if (!(n>=0)) n = 0;
    return n;
  }catch(_){ return 3; }
}
function ensureScrolloff(editor){
  try{
    // ワンショット抑止（/:? 閉じや Esc 取消直後の強制スクロールを回避）
    if (window._suppressScrolloffOnce) { window._suppressScrolloffOnce = false; return; }
    // ワンショット抑止（/:? 閉じや Esc 取消直後の強制スクロールを回避）
    var lh = getLineHeightPx(editor);
    if(!lh || !isFinite(lh) || lh<=0) return;
    var text = editor.value;
    var total = totalLines(text);
      var pos;
      if (typeof mode!=='undefined' && mode===MODE_VISUAL && editor.selectionStart!==editor.selectionEnd){
        if (typeof visActiveEnd==='string'){
          pos = (visActiveEnd==='start') ? editor.selectionStart : editor.selectionEnd;
        } else {
          pos = (lastMotionDir==='up'||lastMotionDir==='left') ? editor.selectionStart : editor.selectionEnd;
        }
      } else {
        pos = (typeof editor.selectionEnd==='number') ? editor.selectionEnd : getCaret(editor);
      }
    var cursorLine = getLineCol(text,pos).line;
  var STATUSBAR_H = (function(){ var cb=document.getElementById('cmdbar'); return cb && cb.offsetHeight ? cb.offsetHeight|0 : 28; })();
    var clientH = editor.clientHeight;
    var visibleH = clientH - STATUSBAR_H;
    if (visibleH < lh) visibleH = lh;
    var curTop = editor.scrollTop;
    var realMax = editor.scrollHeight - clientH;
    if (realMax < 0) realMax = 0;
    var cursorTop    = (cursorLine - 1) * lh;
    var cursorBottom = cursorTop + lh;
    var desiredTop = curTop;
    var scrolloffLines = getScrolloff();
    var upMarginPx   = scrolloffLines * lh;
    var downMarginPx = scrolloffLines * lh;
    var isLastLine = (cursorLine === total);
        /* PATCH:center scrolloff (vim-9999) */
        var visLines = Math.max(1, Math.ceil(visibleH / lh));
        var centerThreshold = Math.floor((visLines - 1) / 2);
        if (scrolloffLines >= centerThreshold){
          // センタリング適用判定（垂直移動時のみ）
          var half = Math.max(0, Math.floor((visibleH - lh)/2));
          var centerTop = cursorTop - half;
          if (centerTop < 0) centerTop = 0;
          if (centerTop > realMax) centerTop = realMax;
          var applyCenter = false;
          try{ applyCenter = (typeof lastMotionDir==='string' && (lastMotionDir==='up' || lastMotionDir==='down')); }catch(_){ }
          if (applyCenter){
            if (Math.abs(centerTop - curTop) >= 0.5) editor.scrollTop = centerTop;
            return;
          } else {
            // 水平移動（h/l, 0, $ など）では余白は無視し、可視範囲内に収めるだけにする
            var viewBottomNV = curTop + visibleH;
            if (cursorTop < curTop){
              editor.scrollTop = Math.max(0, Math.min(realMax, cursorTop));
              return;
            }
            if (cursorBottom > viewBottomNV){
              editor.scrollTop = Math.max(0, Math.min(realMax, cursorBottom - visibleH));
              return;
            }
            // 既に見えているなら何もしない
            return;
          }
        }
    if (isLastLine){
      // 最終行でも scrolloff を考慮（満たせない場合は可能な範囲で）
      var viewBottom = curTop + visibleH;
      // 通常行と同じ式で「下側余白」を優先しつつ、境界でクランプ
      desiredTop = cursorBottom + downMarginPx - visibleH;
      if (desiredTop < 0) desiredTop = 0;
      if (desiredTop > realMax) desiredTop = realMax;
      // 行の上端が隠れてしまう場合は行上端まで持ち上げる（行全体が可視に）
      if (cursorTop < desiredTop){
        desiredTop = cursorTop;
        if (desiredTop < 0) desiredTop = 0;
        if (desiredTop > realMax) desiredTop = realMax;
      }
      // 念のため、行底が隠れるケースをもう一度補正
      viewBottom = desiredTop + visibleH;
      if (cursorBottom > viewBottom){
        desiredTop = cursorBottom - (visibleH - downMarginPx);
        if (desiredTop < 0) desiredTop = 0;
        if (desiredTop > realMax) desiredTop = realMax;
      }
    } else {
      // 通常行: scrolloff
      if (cursorTop - upMarginPx < curTop){
        desiredTop = cursorTop - upMarginPx;
      } else {
        var viewBottom = curTop + visibleH;
        if (cursorBottom + downMarginPx > viewBottom){
          desiredTop = cursorBottom + downMarginPx - visibleH;
        }
      }
      if (desiredTop < 0) desiredTop = 0;
      if (desiredTop > realMax) desiredTop = realMax;
    }
    if (Math.abs(desiredTop - curTop) >= 0.5){
      editor.scrollTop = desiredTop;
    }
  }catch(_){}
}
// ====== コマンドバー ======
function openCmdBar(){
  hideMsg();
  var inp=document.getElementById('cmdline');
  var pre=document.getElementById('cmdprefix');
  pre.style.display = 'inline-block';
  pre.innerText = ':';              // ← 追加: 常にコロンに戻す
  inp.style.display = 'inline-block';
  inp.value='';
  inp.focus();
}
// 検索バー（/ または ?）
function openSearchBar(dir){
  hideMsg();
  var inp = document.getElementById('cmdline');
  var pre = document.getElementById('cmdprefix');
  
  // 現在カーソル位置を保存（/:? 実行時の“包含開始”で使う）
  var ed = document.getElementById('editor');
  window._searchFromPos = ed ? getCaret(ed) : undefined;
  window._searchPrevPat = (window.searchState && searchState.pat) ? searchState.pat : '';
  window._searchPrevDir = (window.searchState && typeof searchState.dir==='number') ? searchState.dir : 1;
  window._searchFromScrollTop = ed ? ed.scrollTop : undefined;
  
  pre.style.display = 'inline-block';
  pre.innerText = (dir >= 0) ? '/' : '?';
  inp.style.display = 'inline-block';
  inp.value = '';
  inp.focus();
  try{ ensureIncPreviewLayer(); clearIncPreview(); }catch(_){ }
  if (typeof bindCmdlineIncSearch==='function') setTimeout(bindCmdlineIncSearch, 0);
  if (typeof bindCmdlineEsc==='function') setTimeout(bindCmdlineEsc, 0);
  if (typeof bindCmdlineIncSearch==='function') setTimeout(bindCmdlineIncSearch, 0);
}
// コマンドライン ESC 取消バインド
function bindCmdlineEsc(){
  var cmd = document.getElementById('cmdline');
  if(!cmd || cmd._escBound) return;
  cmd.addEventListener('keydown', function(e){
    if(e.key === 'Escape'){
      // 補完一覧があればリセット
      if (typeof resetCmdCompl === 'function'){
        try{ resetCmdCompl(); }catch(_){}
      }
      // /,? 入力中のキャンセルは保存位置へ復元
      var pre = document.getElementById('cmdprefix');
      var pfx = pre ? (pre.innerText || pre.textContent || '') : '';
      if ((pfx === '/' || pfx === '?') && typeof window._searchFromPos === 'number'){
        var ed = document.getElementById('editor');
        if (ed){
          var L = ed.value.length;
          setCaret(ed, Math.max(0, Math.min(L, window._searchFromPos)));
        }
      }
      window._searchFromPos = undefined;
      closeCmdBar();
      var ed2 = document.getElementById('editor');
      if(ed2) ed2.focus();
      e.preventDefault();
      e.stopPropagation();
    }
  });
  cmd._escBound = true;
}
// openCmdBar 呼出後に確実に ESC バインド（init 末尾 or openCmdBar 内後段）
(function(){
  var _origOpen = openCmdBar;
  openCmdBar = function(){
    _origOpen.apply(this, arguments);
    // 表示直後にバインド（1回だけ）
    setTimeout(bindCmdlineEsc, 0);
  };
})();
function closeCmdBar(){
  var inp=document.getElementById('cmdline');
  inp.blur();
  inp.style.display = 'none';
  var pre = document.getElementById('cmdprefix');
  pre.style.display = 'none';
  pre.innerText = ':';              // ← 追加: 閉じる時もコロンに初期化
  setMode(MODE_NORMAL, document.getElementById('editor'));
  hideMsg();
  document.getElementById('editor').focus(); 
  try{
    var ed=document.getElementById('editor');
    var p=(typeof window._lastPos==='number')?window._lastPos:((typeof Buffers==='object'&&Buffers.current>=0&&Buffers.list[Buffers.current]&&typeof Buffers.list[Buffers.current].pos==='number')?Buffers.list[Buffers.current].pos:null);
    if(ed && p!=null){
      var L=ed.value.length|0; var P=Math.max(0,Math.min(L,p|0));
      if (ed.setSelectionRange) ed.setSelectionRange(P,P); else if (typeof setCaret==='function') setCaret(ed,P);
    }
  }catch(_){ }
}
// コマンド実行
function runCommand(cmd){
  var s = (cmd || '').trim();
  /* PATCH: scrolloff early :set guard (colon/alias/space-aware) */
  if (/^:?\s*set\s+(scrolloff|so)\s*=\s*\d+\s*$/i.test(s)){
    var n = parseInt(s.replace(/^:?\s*set\s+(scrolloff|so)\s*=\s*/i, ""), 10);
    if (!(n>=0)) n = 0;
    try{ if (typeof OPT!=='object') window.OPT = {}; }catch(_){ }
    OPT.scrolloff = n;
    try{ showMsg("scrolloff=" + n, 1200); }catch(_){ }
    try{ closeCmdBar(); }catch(_){ }
    return;
  }
  // /pattern と ?pattern
  if (s.charAt(0) === '/' || s.charAt(0) === '?'){
    var dir = (s.charAt(0) === '/') ? 1 : -1;
    var pat = s.slice(1);
    // openSearchBar 時に保存した位置を優先（なければ現在位置）
    var ed = document.getElementById('editor');
    var fromPos = (typeof window._searchFromPos === 'number')
      ? window._searchFromPos
      : (ed ? getCaret(ed) : undefined);
    window._suppressScrolloffOnce = true;  // コマンドバー閉鎖時の強制スクロールを1回抑止
    closeCmdBar();
    if (pat) searchState.pat = pat;
    if (!searchState.pat){ showMsg('No search pattern', 1200); return; }
    // 包含開始＋基準方向更新（/:? 用）
    doSearch(searchState.pat, dir, fromPos, { updateBase: true, inclusive: true });
    try{ clearIncPreview(); }catch(_){ }
    window._searchFromScrollTop = undefined;  // 後片付け
    window._searchFromPos = undefined; // 後片付け
    return;
  }
  if (s.charAt(0) === ':') s = s.slice(1);
  if (s === '') { closeCmdBar(); return; }
  // --- buffers: :ls / :buffers ---
  if (/^(ls|buffers)$/i.test(s)){
    // コマンドバーを:b に切替してバッファ一覧の補完UIを表示
    var preEl = document.getElementById('cmdprefix');
    var cmdEl = document.getElementById('cmdline');
    if (preEl){ preEl.style.display='inline-block'; preEl.innerText=':'; }
    if (cmdEl){ cmdEl.style.display='inline-block'; cmdEl.value='b '; cmdEl.focus(); }
    try{ resetCmdCompl(); }catch(_){ }
    try{ updateCmdCompletions(); }catch(_){ }
    return;
  }
  // --- :b / :buffer {spec} ---
  if (/^b(uffer)?(\s+.*)?$/i.test(s)){
    var spec = s.replace(/^b(uffer)?/i,'').trim();
    try{ bufEnsureInitial(); }catch(_){ }
    if (!spec){
      closeCmdBar(); try{ showMsg(bufListString(), true); }catch(_){ showMsg('No buffers', 1000); }
      return;
    }
    var idx = bufFindBySpec(spec);
    if (idx===-1){ closeCmdBar(); showMsg('No such buffer: ' + spec, 1500); return; }
    if (idx && typeof idx==='object' && idx.ambiguous){
      var names=[]; for (var i2=0;i2<idx.hits.length;i2++){ var b=Buffers.list[idx.hits[i2]]; names.push(b.id+': '+_bufMakeName(b.path)); }
      closeCmdBar(); showMsg('Ambiguous: ' + names.join(' , '), 1800); return;
    }
    closeCmdBar(); bufSwitchToIndex(idx); return;
  }
  if (/^u$/i.test(s)){
    closeCmdBar();
    doUndo();
    return;
  }
  if (/^re?do$/i.test(s)){  // :redo / :redo
    closeCmdBar();
    doRedo();
    return;
  }
  // :e! / :e! {file}
  // :e! / :e! {file} → バッファ管理で強制再読込
  if (/^e!/i.test(s)) {
    var tail = s.replace(/^e!/i,'').trim();
    var path = tail || window._currentFile;
    if (!path) { closeCmdBar(); showMsg('No file name', 1600); return; }
    closeCmdBar();
    try{ bufEnsureInitial(); bufOpenFile(path, true); }catch(_){ showMsg('Reload failed',1500); }
    return;
  }
  // help
  if (/^(help|\?)$/i.test(s)) { closeCmdBar(); showHelp(); return; }
  // 数値のみ: 行番号へジャンプ（:99 など）
  if (/^\d+$/.test(s)) {
    var ln = parseInt(s,10);
    function __posCalc(){
      try{ var E=document.getElementById('editor'); if(!E) return 0; return lineFirstNonBlankByNumber(E.value, ln); }catch(_){ return 0; }
    }
    try{ window._suppressScrolloffOnce = true; }catch(_){ }
    closeCmdBar();
    function __applyOnce(){
      try{
        var E=document.getElementById('editor'); if(!E) return;
        var p=__posCalc(); var L=E.value.length|0; var P=Math.max(0,Math.min(L,p|0));
        try{ E.focus(); }catch(_){ }
        setCaret(E, P);
        if (typeof updateStatus==='function') updateStatus(E);
        if (typeof ensureScrolloff==='function') ensureScrolloff(E);
      }catch(_){ }
    }
    __applyOnce(); setTimeout(__applyOnce,0); setTimeout(__applyOnce,40); setTimeout(__applyOnce,90);
    return;
  }
  if (/^dbgpos$/i.test(s)){
    closeCmdBar();
    try{
      var ed=document.getElementById('editor');
      var cur=(typeof Buffers==='object'&&Buffers.current>=0)?Buffers.list[Buffers.current]:null;
      var prv=(typeof Buffers==='object'&&Buffers.prev>=0)?Buffers.list[Buffers.prev]:null;
      var curS=cur?('cur#'+cur.id+' s='+cur.selStart+' e='+cur.selEnd+' p='+cur.pos+' st='+cur.scrollTop):'cur: none';
      var prvS=prv?(' prev#'+prv.id+' s='+prv.selStart+' e='+prv.selEnd+' p='+prv.pos+' st='+prv.scrollTop):'';
      var rt='ed sel=['+ (ed?ed.selectionStart:'-') +','+ (ed?ed.selectionEnd:'-') +'] caret='+ (ed?getCaret(ed):'-') +' st='+ (ed?ed.scrollTop:'-');
      showMsg(curS+prvS+' | '+rt, true);
      try{ if (ed && typeof updateStatus==='function') updateStatus(ed); }catch(_){ }
    }catch(_){ showMsg('dbgpos error', 1200); }
    return;
  }
  if (/^debugscroll$/i.test(s)){
    closeCmdBar();
    var ed = document.getElementById('editor');
    var lh = getLineHeightPx(ed);
    var ch = ed.clientHeight;
    var sh = ed.scrollHeight;
    var STATUSBAR_H = (function(){ var cb=document.getElementById('cmdbar'); return cb && cb.offsetHeight ? cb.offsetHeight|0 : 28; })();
    var effH = ch - STATUSBAR_H;
    var tl = totalLines(ed.value);
    var pos = getCaret(ed);
    var line = getLineCol(ed.value,pos).line;
    var maxST = sh - ch; if (maxST < 0) maxST = 0;
    showMsg('lh='+lh+' ch='+ch+' sh='+sh+' effH='+effH+' scrollTop='+ed.scrollTop+' maxST='+maxST+' line='+line+'/'+tl, true);
    return;
  }
  // set number / nonumber / clipboard
  var m = s.match(/^set\s+(.+)$/i);
  if (m) {
    var arg = m[1].trim().toLowerCase();
    if (arg==='number' || arg==='nu') { OPT.number=true; updateGutter(); closeCmdBar(); return; }
    if (arg==='nonumber' || arg==='nonu') { OPT.number=false; updateGutter(); closeCmdBar(); return; }
    if (arg==='clipboard=os') { OPT.clipboard='os'; showMsg('clipboard=os', 1200); closeCmdBar(); return; }
    if (arg==='clipboard=internal') { OPT.clipboard='internal'; showMsg('clipboard=internal', 1200); closeCmdBar(); return; }
    if (/^(scrolloff|so)\s*=\s*\d+\s*$/i.test(arg)){
      var mso = arg.match(/^(scrolloff|so)\s*=\s*(\d+)\s*$/i);
      var n = mso ? parseInt(mso[2], 10) : 3; if (!(n>=0)) n = 0;
      try{ if (typeof OPT!=='object') window.OPT = {}; }catch(_){ }
      OPT.scrolloff = n; showMsg('scrolloff='+n, 1200); closeCmdBar(); return;
    }
    showMsg('unknown option: ' + arg, 1400); closeCmdBar(); return;
  }
  // === (3) :w / :w! / :w {path} ===
  if (/^w!?(\s+.*)?$/i.test(s)){
    var force = /!/.test(s.split(/\s+/)[0]); // 現状 force で上書き判定差は付けない（予約）
    var arg = s.replace(/^w!?/i,'').trim();
    var editor = document.getElementById('editor');
    var fsoOk = true;
    try { new ActiveXObject("Scripting.FileSystemObject"); } catch(_){ fsoOk=false; }
    if (!fsoOk){
      showMsg('Write not supported (ActiveX disabled)', 2000);
      closeCmdBar();
      return;
    }
    var path = '';
    if (arg){
      path = arg;
      window._currentFile = path;
    } else {
      path = window._currentFile;
    }
    if (!path){
      showMsg('No file name', 1500);
      closeCmdBar();
      return;
    }
    try{
      writeFileUTF8(path, editor.value);
      setBaseline(editor.value);
      undoStack = [];
      redoStack = [];
      insertSessionActive = false;
      pushUndo('initial'); // 保存後のクリーン状態を基点に
      updateStatus(editor);
      showMsg('Written: ' + path, 1400);
    }catch(e){
      showMsg('Write error: ' + path, 2000);
    }
    closeCmdBar();
    return;
  }
  // :e （引数なし）→ 現在ファイルを未変更なら再読込、変更ありなら警告
  if (/^e$/i.test(s)){
    var cur = window._currentFile || '';
    if (!cur){ closeCmdBar(); showMsg('No file name', 1600); return; }
    if (modifiedCount > 0){ closeCmdBar(); showMsg('No write since last change (use :e!)', 1800); return; }
    closeCmdBar();
    try{ bufEnsureInitial(); bufOpenFile(cur, true); }catch(_){ showMsg('Reload failed',1500); }
    return;
  }
  // :e file / :edit file → バッファ管理（既存なら切替・無ければ新規）
  if (/^e(dit)?\s+.+/i.test(s)) {
    try {
      var path = s.replace(/^e(dit)?\s+/i, "").trim();
      closeCmdBar();
      bufEnsureInitial();
      bufOpenFile(path, false);
      return;
    } catch(e) {
      closeCmdBar();
      showMsg("Error loading file", 2000);
      return;
    }
  }
  // quit
  // 強制終了
  if (/^q!$/i.test(s)) {
    closeCmdBar();
    window.close();
    return;
  }
  // quit（警告あり）
  if (/^q$/i.test(s)) {
    if (modifiedCount > 0) {
      closeCmdBar();
      showMsgAuto('編集内容が保存されていません', 1600);
      try{ var __ed=document.getElementById('editor'); if(__ed) __ed.focus(); }catch(_){ }
      return;
  }
    closeCmdBar();
    window.close();
    return;
  }
  showMsg('未実装: ' + s, 1200);
  closeCmdBar();
}
// === 追加: 保存ヘルパ (runCommand より前のグローバル領域に) ===
function writeFileUTF8(path, content){
  // LF 正規化（v1 では LF 固定）
  content = content.replace(/\r\n?/g, '\n');
  var st = new ActiveXObject("ADODB.Stream");
  st.Type = 2;
  st.Charset = "UTF-8";
  st.Open();
  st.WriteText(content);
  st.Position = 0;
  st.SaveToFile(path, 2 /*adSaveCreateOverWrite*/);
  st.Close();
}
// ====== 入力処理 ======
var _skipComplRecalc = false; // ←追加: Esc 後の補完再計算を1回だけ抑止するフラグ
function composing(e){ return e && (e.isComposing || e.keyCode===229); }
function handleMove(editor, target, selecting){
  var text = editor.value;
  target = Math.max(0, Math.min(target, text.length));
  if(mode===MODE_VISUAL||selecting){
    if(anchorPos==null) anchorPos=getCaret(editor);
    // VISUALモード時はexclusive selection
    if (mode === MODE_VISUAL) {
      setSelection(editor, anchorPos, target);
      // どちら側が“動いた端”かを記録（次のモーション基準に使う）
      visActiveEnd = (target < anchorPos) ? 'start' : 'end';
    } else {
      setSelection(editor, anchorPos, target);
    }
  } else {
    setCaret(editor, target);
  }
  // 移動系コマンドが実行されたので、ddの追記チェーンはここで切る
  lastCmd = 'move';
  updateStatus(editor); ensureScrolloff(editor);
}
function tryEmacsCtrl(editor,e){
  // Emacs互換移動キーは廃止。Ctrl+R (Redo) のみ維持。
  if(!e.ctrlKey||e.altKey) return false;
  var k = (typeof e.key==='string'
           ? e.key.toLowerCase()
           : String.fromCharCode(e.keyCode).toLowerCase());
  if (k === 'r'){ // Ctrl+R = redo
    doRedo();
    e.preventDefault(); e.stopPropagation();
    return true;
  }
  return false;
}
// --- IE9 互換: 右下ハンドルでウィンドウサイズ変更（枠ドラッグ不可の代替） ---
function ensureWindowResizer(){
  try{
    var h=document.getElementById('winresizer');
    if(!h){
      h=document.createElement('div'); h.id='winresizer'; document.body.appendChild(h);
    }
    if(h._bound) return; h._bound=true;
    var dragging=false,lastX=0,lastY=0;
    function onMove(e){ if(!dragging) return; e=e||window.event; var x=e.screenX||0,y=e.screenY||0; var dx=x-lastX,dy=y-lastY; if(dx||dy){ try{ window.resizeBy(dx,dy); }catch(_){ } lastX=x; lastY=y; } if(e.preventDefault) e.preventDefault(); return false; }
    function onUp(e){ if(!dragging) return; dragging=false; try{ document.removeEventListener('mousemove',onMove,true);}catch(_){ } try{ document.removeEventListener('mouseup',onUp,true);}catch(_){ } try{ if(h.releaseCapture) h.releaseCapture(); }catch(_){ } if(e&&e.preventDefault) e.preventDefault(); return false; }
    h.onmousedown=function(e){ e=e||window.event; dragging=true; lastX=e.screenX||0; lastY=e.screenY||0; try{ if(h.setCapture) h.setCapture(); }catch(_){ } try{ document.addEventListener('mousemove',onMove,true);}catch(_){ } try{ document.addEventListener('mouseup',onUp,true);}catch(_){ } if(e.preventDefault) e.preventDefault(); return false; };
    h.ondblclick=function(){ try{ if(window.app){ var st=String(app.windowState||'').toLowerCase(); app.windowState=(st==='maximize'?'normal':'maximize'); } }catch(_){ } };
  }catch(_){ }
}
// ====== INIT ======
(function init(){
  var editor=document.getElementById('editor');
  try{ if (window.app){
    try{ if (String(app.border||'').toLowerCase()!=='thick') app.border='thick'; }catch(_){ }
    try{ app.caption='yes'; app.sysmenu='yes'; app.maximizeButton='yes'; app.minimizeButton='yes'; }catch(_){ }
    try{ if (String(app.windowState||'').toLowerCase()!=='normal') app.windowState='normal'; }catch(_){ }
  } }catch(_){ }
  editor.value =
    '# Vi-like Text Editor "six" v0.3.3 (paste+help)\n' +
    '行番号: :set number / :set nonumber（起動時は number=on）。wrap=off 前提。\n' +
    '移動: h j k l / ←↓↑→ / w b / ^（先頭非空白）/ 0 / $ / 段落 { }\n' +
    'モード: i → INSERT, v → VISUAL, Esc → NORMAL\n' +
    'ペースト: INSERTでCtrl+V/Shift+Ins/右クリック可（改行はLFに正規化）。NORMALでは不可。\n' +
    'ヘルプ: F1 または :help\n';
  editor.focus();
  setMode(MODE_NORMAL,editor);
  setCaret(editor, 0);
  pushUndo('initial');
  setBaseline(editor.value);
  updateStatus(editor); ensureScrolloff(editor); updateGutter();
  // 行番号ガターの初期表示
  updateGutter();
  // ステータスバー初期表示
  document.getElementById('cmdline').style.display = 'none';
  document.getElementById('cmdprefix').style.display = 'none';
  try{ bufEnsureInitial(); }catch(_){ }
  // 追加: 起動引数（app.CommandLine）でファイルを開く（存在→読込／非存在→新規）
  (function(){
    var a = _getStartupArgFromApp();
    if (!a) return;
    var full = _resolveAgainstHtaDir(a);
    _openFileOrNewOnStartup(full);
  })();
  // --- キー処理（エディタ） ---
  editor.addEventListener('keydown', function(e){
    var __cmd=document.getElementById('cmdline'); if(__cmd && (__cmd.style.display==='inline-block'||__cmd.style.display==='block')) return;
    if(tryEmacsCtrl(editor,e)) return;
    var key = (typeof e.key==='string')?e.key:String.fromCharCode(e.keyCode);
    var lower = key.toLowerCase();
    var text=editor.value, pos=getCaret(editor);
    // 追加: F1 は editor 側で早期処理（NORMAL/VISUAL でも stopPropagation 前に処理）
    if ((key === 'F1') || e.keyCode === 112){
      e.preventDefault(); e.stopPropagation();
      showHelp();
      var sc = document.getElementById('helpScroll'); if (sc) sc.focus();
      return;
    }
    // 追加: 矢印キーを hjkl と同等に正規化（IE9 keyCode も対応）
    if (lower === 'arrowleft')  lower = 'h';
    else if (lower === 'arrowdown') lower = 'j';
    else if (lower === 'arrowup')   lower = 'k';
    else if (lower === 'arrowright')lower = 'l';
    else {
      if (e.keyCode===37) lower='h';
      else if (e.keyCode===40) lower='j';
      else if (e.keyCode===38) lower='k';
      else if (e.keyCode===39) lower='l';
    }
    // --- 修飾キー単独押下は状態を壊さず無視 ---
    if (
      key === 'Shift' || key === 'Control' || key === 'Alt' || key === 'Meta' ||
      e.keyCode === 16 || e.keyCode === 17 || e.keyCode === 18 || e.keyCode === 91
    ) {
      return;
    }
    if(mode===MODE_INSERT){
      if(composing(e)) return;
      if(key==='Escape'||e.keyCode===27){
        e.preventDefault();
        e.stopPropagation();
        setMode(MODE_NORMAL,editor);
        return;
      }
      return; // 通常入力は素通し
    }
    // NORMAL / VISUAL
    if(composing(e)){ e.preventDefault(); }
    e.preventDefault(); e.stopPropagation();
    // モード切替・ヘルプ・Ex
    if (lower==='i'){
      if (e.shiftKey || key==='I'){
        var pI = getCaret(editor);
        var sI = firstNonBlankPos(text, pI);
        setCaret(editor, sI);
        setMode(MODE_INSERT, editor);
      } else {
        setMode(MODE_INSERT, editor);
      }
      return;
    }
    if(lower==='v'){ setMode(mode===MODE_VISUAL?MODE_NORMAL:MODE_VISUAL,editor); return; }
    if(key==='Escape'||e.keyCode===27){ setMode(MODE_NORMAL,editor); return; }
    if(key===':'){ openCmdBar(); return; }
    // 追加: 検索起動（/ 前方, ? 後方）とリピート
    if (lower === '/') { openSearchBar(1); return; }
    if (lower === '?') { openSearchBar(-1); return; }
    // n: 直前方向（Shiftなし）
    if (lower === 'n' && !e.shiftKey) {
      if (searchState && searchState.pat) {
        var cnt = takeCount(1);
        for (var i=0; i<cnt; i++){ doSearch(searchState.pat, searchState.dir); }
      } else {
        showMsg('No previous search', 1000);
      }
      return;
    }
    // N: 逆方向（Shift+N または N キー判定）
    if (key === 'N' || (lower === 'n' && e.shiftKey)) {
      if (searchState && searchState.pat) {
        var cnt2 = takeCount(1);
        for (var i=0; i<cnt2; i++){ doSearch(searchState.pat, -searchState.dir); }
      } else {
        showMsg('No previous search', 1000);
      }
      return;
    }
    // --- 数値接頭辞 ---
    if (lower>='0' && lower<='9'){
      if (lower==='0' && countBuffer===''){
        // 単独 0 は行頭コマンド
      } else {
        countBuffer += lower;
        return;
      }
    }
    function takeCount(def){
      var n = parseInt(countBuffer||'',10);
      countBuffer='';
      if(!isFinite(n) || n<=0) return (def==null?1:def);
      return n;
    }
    // --- G / NG 早期処理（大文字 G 判定を強化）---
    var isUpperG = (key === 'G') || (e.shiftKey && (key === 'g' || key === 'G')) || (e.shiftKey && e.keyCode === 71);
    if (isUpperG){
      var tl  = totalLines(text);
      var curLine = getLineCol(text, pos).line;
      var raw = countBuffer; countBuffer='';
      var n = parseInt(raw||'',10);
      var line = (isFinite(n)&&n>0) ? Math.min(tl,n) : tl;
      if (opPending === 'd'){
        deleteLineRange(editor, text, curLine, line);
               opPending=null; opRepeat=1; gPending=false;
        return;
      }
      // 要望: 最終行で末尾改行なし→行末(=EOF)、末尾改行あり→改行文字位置
      var startIdx = lineStartByNumber(text, line);
      var targetPos;
      if (line === tl){
        // 末尾が改行なら改行文字位置、無ければ EOF (=その行末)
        targetPos = (text.charAt(text.length-1)==='\n') ? text.length-1 : text.length;
        // 安全: startIdx を越えているならそのまま（textarea では text.length も妥当）
        if (targetPos < startIdx) targetPos = startIdx;
      }else{
        // 中間行は行頭（好みにより firstNonBlank へ変更可）
        targetPos = startIdx;
      }
      lastMotionDir = (line >= curLine) ? 'down' : 'up';
      handleMove(editor, targetPos, mode===MODE_VISUAL);
      // 明示再調整
      ensureScrolloff(editor);
      gPending = false;
      return;
    }
    // 'g' 以外入力で gPending 解除（上の G 早期処理後に判定）
    if (lower !== 'g') gPending = false;
    // 移動（NORMAL/ VISUAL）
    var target=pos, selecting=(mode===MODE_VISUAL);
    switch(lower){
      // --- g / gg / Ngg 専用（G は早期処理へ分離）---
      case 'g': {
        // gg / Ngg
         if (gPending){
           var raw2 = countBuffer; countBuffer='';
           var n2 = parseInt(raw2||'',10);
           var line2 = (isFinite(n2)&&n2>0) ? n2 : 1;
           var curLineObj2 = getLineCol(text, pos);
           if (opPending === 'd'){
             // dgg / dNgg 行単位削除
             deleteLineRange(editor, text, curLineObj2.line, line2);
             opPending=null; opRepeat=1; gPending=false;
             return;
           }
           var tpos2 = lineFirstNonBlankByNumber(text, line2);
           lastMotionDir = (line2 < curLineObj2.line) ? 'up' : 'down';
           target = tpos2;
           gPending=false;
           break;
         } else {
           // 1文字目の 'g' 待機（カウントは保持したまま）
           gPending=true;
           return;
         }
      }
      case 'u': { // undo
        if (mode===MODE_NORMAL){
          doUndo();
          countBuffer=''; opPending=null; opRepeat=1;
          return;
        }
        break;
      }
      // --- 削除（単体） ---
      case 'x': {
        if (mode!==MODE_INSERT){
          var n = takeCount(1);
          if (pos < text.length) deleteRange(editor, pos, Math.min(text.length, pos+n));
          opRepeat = 1; // 単発コマンドで演算子カウントはリセット
          return;
        }
        break;
      }
      // --- 貼り付け ---
      case 'p':
        if (mode!==MODE_INSERT){ pasteAfter(editor); countBuffer=''; opRepeat=1; return; }
        break;
      case 'P':
        if (mode!==MODE_INSERT){ pasteBefore(editor); countBuffer=''; opRepeat=1; return; }
        break;
     
      // --- 演算子 d （次のモーションで削除）---
      // --- 追加: o/O （行を開いて INSERT） ---
      // 追加: o/O （行を開いて INSERT）
      case 'o': {
        if (mode!==MODE_INSERT){
          if (e.shiftKey || key==='O') { openLineAbove(editor); } else { openLineBelow(editor); }
          countBuffer=''; opPending=null; opRepeat=1; gPending=false; return;
        }
        break;
      }
      // --- 追加: a/A （右/行末で INSERT） ---
      // 追加: a/A （右/行末で INSERT）
      case 'a': {
        if (mode!==MODE_INSERT){
          if (e.shiftKey || key==='A') {
            var pA = getCaret(editor);
            var eA = lineEndIndex(text, pA);
            setCaret(editor, eA);
            setMode(MODE_INSERT, editor);
          } else {
            var p = getCaret(editor);
            setCaret(editor, Math.min(text.length, p+1));
            setMode(MODE_INSERT, editor);
          }
          countBuffer=''; opPending=null; opRepeat=1; gPending=false; return;
        }
        break;
      }
      case 'd': {
        if (mode!==MODE_INSERT){
          if (opPending === 'd') {
            var lines = opRepeat * takeCount(1);
            if (lines < 1) lines = 1;
            var ls = lineStartIndex(text, pos);
            var tpos = pos, lastEnd = lineEndIndex(text, tpos);
            for (var i=1;i<lines;i++){
              if (lastEnd >= text.length) break;
              var nextStart = lastEnd + 1;
              lastEnd = lineEndIndex(text, nextStart);
            }
            var e  = (lastEnd < text.length) ? lastEnd + 1 : lastEnd;
            deleteRange(editor, ls, e, { linewise: true });
            opPending = null;
            opRepeat = 1;
            return;
          }
          opPending = 'd';
          opRepeat = takeCount(1);
          return;
        }
        break;
      }
      case 'h': {
        var p = getActivePosForDir(editor,'left');
        var n = takeCount(1);
        if (opPending === 'd'){
          if (p > 0) deleteRange(editor, Math.max(0, p-n), p); // d{n}h
          opPending = null;
          opRepeat = 1;
          return;
        }
        target=Math.max(0,p-n); lastMotionDir='left'; break;
      }
      case 'l': {
        var p = getActivePosForDir(editor,'right');
        var n = takeCount(1);
        if (opPending === 'd'){
          if (p < text.length) deleteRange(editor, p, Math.min(text.length, p+n)); // d{n}l
          opPending = null;
          opRepeat = 1;
          return;
        }
        target=Math.min(text.length,p+n); lastMotionDir='right'; break;
      }
      case 'j': {
        var n = takeCount(1);
        // j の基準位置（VISUAL 対応）
        var p = getActivePosForDir(editor,'down');
        var tl = totalLines(text);
        var curLine = getLineCol(text, p).line;
        // 既に最終行なら何もしない（末尾改行有無どちらでも不動）
        if (curLine === tl) {
          // 演算子待機中 (d など) の場合は取り消し
          if (opPending) { opPending = null; opRepeat = 1; }
          break;
        }
        // 下へ n 行（1 行ずつ進めて途中で最終行に到達したら停止）
        var newPos = p;
        for (var i = 0; i < n; i++) {
          var step = posDown(text, newPos, 1);
          if (step === newPos) break; // 進めない（安全策）
          newPos = step;
          if (getLineCol(text, newPos).line >= tl) break;
        }
        // 実質移動できなければ終了
        if (newPos === p) {
          if (opPending) { opPending = null; opRepeat = 1; }
          break;
        }
        // d{count}j のような演算子付き（未実装なら無視）
        if (opPending === 'd') {
          // 現在行頭～移動先行頭直前までを削除（簡易。必要なら行単位処理に拡張）
          var startLine = getLineCol(text, p).line;
            var endLine = getLineCol(text, newPos).line;
          deleteLineRange(editor, text, startLine, endLine);
          opPending = null; opRepeat = 1;
          break;
        }
        target = newPos;
        lastMotionDir = 'down';
        break;
      }
      case 'k': {
        var p = getActivePosForDir(editor,'up');
        var n = takeCount(1);
        target=posUp(text,p,n); lastMotionDir='up'; break;
      }
      case 'w': {
        var nMotion = takeCount(1);
        var tl = totalLines(text);
        var curLine = getLineCol(text, pos).line;
        if (curLine === tl){ if (opPending) { opPending=null; opRepeat=1; } break; }
        var nTotal = (opPending===d ? opRepeat*nMotion : nMotion);
        var p0 = (opPending===d ? pos : getActivePosForDir(editor,'right'));
        var t = p0;
        for (var i=0;i<nTotal;i++){ var next = wordRightPos(text, t); if (next === t) break; t = next; }
        if (opPending===d){ if (t > pos) deleteRange(editor, pos, t); opPending=null; opRepeat=1; return; }
        if (t === pos || t === p0){ break; }
        var oldLineW = getLineCol(text, p0).line;
        var newLineW = getLineCol(text, t).line;
        if (newLineW > oldLineW) lastMotionDir=down;
        else if (newLineW < oldLineW) lastMotionDir=up;
        else lastMotionDir=right;
        target = t;
        break;
      }
      case 'b': {
        var nMotion = takeCount(1);
        var nTotal = (opPending===d? opRepeat*nMotion : nMotion);
        var p0 = (opPending===d? pos : getActivePosForDir(editor,'left'));
        var t = p0;
        for (var i=0;i<nTotal;i++){ var next = wordLeftPos(text, t); if (next === t) break; t = next; }
        if (opPending===d){ if (t < pos) deleteRange(editor, t, pos); opPending=null; opRepeat=1; return; }
        var oldLineB = getLineCol(text, p0).line;
        var newLineB = getLineCol(text, t).line;
        if (newLineB > oldLineB) lastMotionDir=down;
        else if (newLineB < oldLineB) lastMotionDir=up;
        else lastMotionDir=left;
        target = t;
        break;
      }
      case '$': {
        // カウントありの $ は n 行下の行末へ（Vim互換: 2$ で次行の行末）
        var dirVis = (mode===MODE_VISUAL && editor.selectionStart!==editor.selectionEnd && (lastMotionDir==='left'||lastMotionDir==='up')) ? 'left' : 'right';
        var nMotion = takeCount(1);
        if (opPending === 'd'){
          var nTotal = Math.max(1, opRepeat * nMotion);
          var tpos = pos, tend = lineEndIndex(text, tpos);
          for (var i=1;i<nTotal;i++){
            if (tend >= text.length) break;
            var ns = tend + 1;
            tend = lineEndIndex(text, ns);
          }
          if (tend > pos) deleteRange(editor, pos, tend);
          opPending=null; opRepeat=1; return;
        }
        var pbase = getActivePosForDir(editor, dirVis);
        var tpos = pbase, tend = lineEndIndex(text, tpos);
        for (var i=1;i<nMotion;i++){
          if (tend >= text.length) break;
          var ns = tend + 1;
          tend = lineEndIndex(text, ns);
        }
        target = tend; lastMotionDir = dirVis; break;
      }
      case '0': {
        // VISUAL時は直前の移動方向に応じて“動いている端”の行頭へ
        (function(){
          var isVisual = (mode===MODE_VISUAL && editor.selectionStart!==editor.selectionEnd);
          var dir = (isVisual && (lastMotionDir==='right'||lastMotionDir==='down')) ? 'right' : 'left';
          var p = getActivePosForDir(editor, dir);
          target = lineStartIndex(text, p);
          lastMotionDir = dir;
          countBuffer=''; // 0 は行頭。数値は消費済み扱い。
        })();
        break;
      }
 
      case '^': {
        // VISUAL時は直前の移動方向に応じて“動いている端”の先頭非空白へ
        (function(){
          var isVisual = (mode===MODE_VISUAL && editor.selectionStart!==editor.selectionEnd);
          var dir = (isVisual && (lastMotionDir==='right'||lastMotionDir==='down')) ? 'right' : 'left';
          var p = getActivePosForDir(editor, dir);
          target = firstNonBlankPos(text, p);
          lastMotionDir = dir;
          countBuffer=''; // ^ は行頭非空白。数値は使わない。
        })();
        break;
      }
      case '{': {
        var p = getActivePosForDir(editor,'up');
        var n = takeCount(1);
        var t = p; for (var i=0;i<n;i++){ t = paragraphPrev(text, t); }
        target=t; lastMotionDir='up'; break;
      }
      case '}': {
        var p = getActivePosForDir(editor,'down');
        var n = takeCount(1);
        var t = p; for ( var i=0;i<n;i++){ t = paragraphNext(text, t); }
        target=t; lastMotionDir='down'; break;
      }
      default:
        // NORMAL での OS ペースト・コンテキストメニュー抑止（paste イベントでも弾くが、ヒントを出す）
        if ((e.ctrlKey && !e.altKey && lower==='v') || (e.shiftKey && e.key==='Insert')) {
          showMsg('NORMALでは貼り付けできません（i で INSERT へ）', 1400);
        }
        // 無関係キーで d をキャンセル
        opPending = null; opRepeat=1; countBuffer='';
        gPending = false;
        return;
    }
    handleMove(editor,target,selecting);
  });
  // スクロール/入力/リサイズ
  editor.addEventListener('scroll', function(){ updateGutter(); });
  editor.addEventListener('input',  function(){
    updateStatus(editor); ensureScrolloff(editor); updateGutter();
    modifiedCount++; updateModifiedFlag();
  });
  editor.addEventListener('click',  function(){ updateStatus(editor); ensureScrolloff(editor); if(mode!==MODE_VISUAL) anchorPos=null; });
  window.addEventListener('resize', function(){
    try{ updateGutter(); }catch(_){ }
    try{ var ed=document.getElementById('editor'); if(ed){ if(typeof updateStatus==='function') updateStatus(ed); if(typeof ensureScrolloff==='function') ensureScrolloff(ed); } }catch(_){ }
  });
  // 行番号表示のためのイベント
  editor.addEventListener('keyup', function(){ updateGutter(); });
  editor.addEventListener('blur', function(){ try{ bufCaptureFromEditor(); }catch(_){ } });
  editor.addEventListener('focus', function(){
    try{
      if (window._pendingSel){
        var ps = window._pendingSel; window._pendingSel=null;
        if (typeof reapplyCaretDeferred==='function') reapplyCaretDeferred(ps.s|0, ps.e|0, ps.cp|0);
      }
    }catch(_){ }
  });
  // ペースト：INSERT 以外は拒否。INSERT では LF 正規化。
  editor.addEventListener('paste', function(e){
    // NORMAL/VISUAL では完全拒否
    if (mode !== MODE_INSERT) {
      e.preventDefault(); e.stopPropagation();
      showMsg('NORMALでは貼り付けできません（i で INSERT へ）', 1200);
      return;
 }
    // INSERT：クリップボードからテキスト取得して LF 正規化
    var t = (window.clipboardData && window.clipboardData.getData('Text'));
    if (typeof t === 'string') {
      pushUndo('paste');
      e.preventDefault(); e.stopPropagation();
      // v1 は LF 固定。将来は OPT.fileformat で 'dos' 時に \r\n に正規化。
      t = t.replace(/\r\n?/g, '\n');
      var s = editor.selectionStart, en = editor.selectionEnd, v = editor.value;
      editor.value = v.slice(0, s) + t + v.slice(en);
      var newPos = s + t.length;
      if (editor.setSelectionRange) editor.setSelectionRange(newPos, newPos);
      updateStatus(editor); ensureScrolloff(editor); updateGutter();
    }
    // それ以外（安全のため既定も許可しない）
  });
  // F1 でヘルプ
  window.addEventListener('keydown', function(e){
    // ← 置換済みのグローバルF1判定はこのままでOK（editorで捕捉できない場合の保険）
    if ((e.key && e.key === 'F1') || e.keyCode === 112) {
      if (e.preventDefault) e.preventDefault(); else e.returnValue = false;
      if (e.stopPropagation) e.stopPropagation();
      showHelp();
      var sc = document.getElementById('helpScroll'); if (sc) sc.focus();
      return;
    }
    // Help表示中の Esc
    if (e.key === 'Escape' && document.getElementById('help').style.display==='block') {
      e.preventDefault(); hideHelp(); return;
    }
    // ESCで警告メッセージを消す（cmdmsgが表示されている場合も対応）
    if (
      e.key === 'Escape' &&
      showMsg._hold &&
      document.getElementById('cmdmsg').style.display !== 'none'
    ) {
      hideMsg();
      setTimeout(function(){
        document.getElementById('editor').focus();
  try{
    var ed=document.getElementById('editor');
    var p=(typeof window._lastPos==='number')?window._lastPos:((typeof Buffers==='object'&&Buffers.current>=0&&Buffers.list[Buffers.current]&&typeof Buffers.list[Buffers.current].pos==='number')?Buffers.list[Buffers.current].pos:null);
    if(ed && p!=null){
      var L=ed.value.length|0; var P=Math.max(0,Math.min(L,p|0));
      if (ed.setSelectionRange) ed.setSelectionRange(P,P); else if (typeof setCaret==='function') setCaret(ed,P);
    }
  }catch(_){ }
      }, 0);
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    // メッセージ表示中でも「:」でコマンドバーに切り替え
    if (e.key === ':' && showMsg._hold) {
      hideMsg();
      openCmdBar();
      return;
    }
    // コマンドバー表示中はESCで閉じる
    if (e.key === 'Escape' && document.getElementById('cmdline').style.display === 'inline-block') {
      hideMsg(); // ←追加
      closeCmdBar();
      return;
    }
  });
  // cmdline 基本ハンドラ内 Esc 判定を拡張
  var cmd=document.getElementById('cmdline');
  cmd.addEventListener('keydown', function(e){
    var k = e.key;
    var kc = e.keyCode;
    // Enter / Esc は先に処理
    if (kc === 27 || k === 'Escape' || k === 'Esc'){
      e.preventDefault(); e.stopPropagation();
      // 追加: /,? 入力のキャンセル時は保存位置へ復元
      try{
        var pre = document.getElementById('cmdprefix');
        var pfx = pre ? (pre.innerText || pre.textContent || '') : '';
        if ((pfx === '/' || pfx === '?') && typeof window._searchFromPos === 'number'){
          var ed = document.getElementById('editor');
          if (ed){
            var L = ed.value.length;
            setCaret(ed, Math.max(0, Math.min(L, window._searchFromPos)));
          }
        }
      }catch(_){}
      window._searchFromPos = undefined;  // 後片付け
      window._searchFromScrollTop = undefined;
      window._suppressScrolloffOnce = true;  // 閉じる際の強制スクロールを1回抑止
      resetCmdCompl();
      _skipComplRecalc = true;
      try{ clearIncPreview(); }catch(_){ }
      closeCmdBar();
      return;
    }
    if (kc === 13 || k === 'Enter'){
      e.preventDefault(); e.stopPropagation();
      hideMsg();
      // prefix（: / ?）を付けて runCommand へ
      var preEl = document.getElementById('cmdprefix');
      var pref = (preEl && preEl.style.display!=='none') ? (preEl.innerText||preEl.textContent||'') : '';
      // 補完アクティブ時は現在候補を確定してから実行
      try{ if (typeof cmdCompl==='object' && cmdCompl.active) commitCmdCompletion(); }catch(_){ }
      runCommand((pref||'') + (cmd.value||''));
      return;
    }
    // 補完中の特殊キー
    if (cmdCompl.active){
      if (k === 'Tab'){
        e.preventDefault(); e.stopPropagation();
        if (e.shiftKey) cycleCmdCompl(-1);
        else cycleCmdCompl(1);
        return;
      }
      if (k === 'ArrowDown' || k === 'Down'){
        e.preventDefault(); e.stopPropagation();
        // 補完リストを1つ進めるだけ（検索処理はここには入れない）
        cycleCmdCompl(1);
        return;
      }
      if (k === 'ArrowUp' || k === 'Up'){
        e.preventDefault(); e.stopPropagation();
        cycleCmdCompl(-1); return;
      }
      if ((e.ctrlKey && (k==='ArrowRight' || k==='Right')) || (e.ctrlKey && e.keyCode===39)){
        // Ctrl+→ で確定
        e.preventDefault(); e.stopPropagation();
        commitCmdCompletion();
        return;
      }
      if (k === 'Tab' && e.ctrlKey){
        e.preventDefault(); e.stopPropagation();
        commitCmdCompletion();
        return;
      }
    } else {
      // 非アクティブ時に Tab → 補完開始（:e / :e! の時のみ）
      if (k === 'Tab'){
        var val = cmd.value;
        if (/^:?(e!?)(\s+).*/i.test(val)){
          e.preventDefault(); e.stopPropagation();
          updateCmdCompletions();
          if (!cmdCompl.active){
            showMsg('候補なし', 900);
          }
        } else {
          // 何もしない（通常はフォーカス移動だがここでは抑止しない）
          // e.preventDefault();
        }
        return;
      }
    }
    // 文字入力など → keydown 時点では value まだ更新されていないので後で再計算
    setTimeout(function(){
      if(_skipComplRecalc){ _skipComplRecalc=false; return; } // ←追加
      // 入力中に補完開始条件を満たしたら開始
      updateCmdCompletions();
    },0);
  });
  // cmdbar自体へのESC/コマンド切替
  document.getElementById('cmdbar').addEventListener('keydown', function(e){
    // 追加: コマンドライン表示中は最優先で ESC 取消
    if (e.key === 'Escape') {
      var cmdEl = document.getElementById('cmdline');
      if (cmdEl && cmdEl.style.display === 'inline-block') {
        resetCmdCompl();
        closeCmdBar();
        e.preventDefault();
        e.stopPropagation();
        return;
      }
    }
    if (e.key === 'Escape' && showMsg._hold) {
      hideMsg();
      document.getElementById('editor').focus();
  try{
    var ed=document.getElementById('editor');
    var p=(typeof window._lastPos==='number')?window._lastPos:((typeof Buffers==='object'&&Buffers.current>=0&&Buffers.list[Buffers.current]&&typeof Buffers.list[Buffers.current].pos==='number')?Buffers.list[Buffers.current].pos:null);
    if(ed && p!=null){
      var L=ed.value.length|0; var P=Math.max(0,Math.min(L,p|0));
      if (ed.setSelectionRange) ed.setSelectionRange(P,P); else if (typeof setCaret==='function') setCaret(ed,P);
    }
  }catch(_){ }
      e.preventDefault();
      e.stopPropagation();
    }
    if (e.key === ':' && showMsg._hold) {
      hideMsg();
      openCmdBar();
      e.preventDefault();
      e.stopPropagation();
    }
  });
  // cmdmsgへのESC/コマンド切替
  document.getElementById('cmdmsg').addEventListener('keydown', function(e){
    if (showMsg._hold && (e.key === 'Escape' || e.key === ':')) {
      hideMsg();
      if (e.key === ':') {
        openCmdBar();
      } else {
        document.getElementById('editor').focus();
  try{
    var ed=document.getElementById('editor');
    var p=(typeof window._lastPos==='number')?window._lastPos:((typeof Buffers==='object'&&Buffers.current>=0&&Buffers.list[Buffers.current]&&typeof Buffers.list[Buffers.current].pos==='number')?Buffers.list[Buffers.current].pos:null);
    if(ed && p!=null){
      var L=ed.value.length|0; var P=Math.max(0,Math.min(L,p|0));
      if (ed.setSelectionRange) ed.setSelectionRange(P,P); else if (typeof setCaret==='function') setCaret(ed,P);
    }
  }catch(_){ }
      }
      e.preventDefault();
      e.stopPropagation();
    }
  });
  // どこでもESCで警告を消す（window, body, document）
  function globalEscHandler(e){
    var cmdmsgElem = document.getElementById('cmdmsg');
    if (!cmdmsgElem) return; // ←この行を追加
    if (
      e.key === 'Escape' &&
      showMsg._hold &&
      cmdmsgElem.style.display !== 'none'
    ) {
      hideMsg();
      setTimeout(function(){
        document.getElementById('editor').focus();
  try{
    var ed=document.getElementById('editor');
    var p=(typeof window._lastPos==='number')?window._lastPos:((typeof Buffers==='object'&&Buffers.current>=0&&Buffers.list[Buffers.current]&&typeof Buffers.list[Buffers.current].pos==='number')?Buffers.list[Buffers.current].pos:null);
    if(ed && p!=null){
      var L=ed.value.length|0; var P=Math.max(0,Math.min(L,p|0));
      if (ed.setSelectionRange) ed.setSelectionRange(P,P); else if (typeof setCaret==='function') setCaret(ed,P);
    }
  }catch(_){ }
      }, 0);
      e.preventDefault();
      e.stopPropagation();
      return;
    }
  }
  // グローバルESCハンドラはinit内で即時登録
  window.addEventListener('keydown', globalEscHandler, true);
  document.body.addEventListener('keydown', globalEscHandler, true);
  document.addEventListener('keydown', globalEscHandler, true);
  // === Command-line completion (GLOBAL) for :e / :e! ===
  var cmdCompl = {
    active:false,
    list:[],
    labels:[],
    index:-1,
    head:'',
    typed:'',
    filterPrefix:'' // 初回起動時の入力（以後フィルタを狭めないため保持）
  };
  function resetCmdCompl(){
    cmdCompl.active = false;
    cmdCompl.list = [];
    cmdCompl.index = -1;
    cmdCompl.head = '';
    cmdCompl.typed = '';
    hideCmdCompletions();
  }
  function buildFileCompletions(prefix){
    try{
      var fso=new ActiveXObject("Scripting.FileSystemObject");
      var dir, base;
      var lastSep = Math.max(prefix.lastIndexOf('\\'), prefix.lastIndexOf('/'));
      if(lastSep>=0){
        dir = prefix.slice(0,lastSep+1);
        base= prefix.slice(lastSep+1);
        if(!dir) dir='.\x5c';
      }else{
        dir='.\x5c'; base=prefix;
      }
      var folder; try{ folder=fso.GetFolder(dir); }catch(_){ return []; }
      var eFiles=new Enumerator(folder.Files);
      var out=[];
      for(; !eFiles.atEnd(); eFiles.moveNext()){
        var name=String(eFiles.item().Name);
        if(!base || name.toLowerCase().indexOf(base.toLowerCase())===0){
          out.push(dir + name);
        }
      }
      out.sort();
      return out;
    }catch(_){ return []; }
  }
  function ensureCmdComplBox(){
    var box=document.getElementById('cmdcomplist');
    if(!box){
      box=document.createElement('div');
      box.id='cmdcomplist';
      box.style.cssText=[
        'position:absolute','left:6px','bottom:60px','max-width:70%','max-height:180px',
        'overflow:auto','background:#202124','border:1px solid #555',
        'font:12px Consolas,monospace','color:#ddd','padding:4px 6px','z-index:50',
        'box-shadow:0 4px 12px rgba(0,0,0,.45)'
      ].join(';');
      document.body.appendChild(box);
    }
    return box;
  }
  function showCmdCompletions(list){
    var box=ensureCmdComplBox();
    if(!list.length){ box.style.display='none'; return; }
    var html=[];
    for(var i=0;i<list.length;i++){
      var sel=(i===cmdCompl.index);
      var raw=(cmdCompl.labels && cmdCompl.labels[i])?cmdCompl.labels[i]:list[i];
      var isCur = (raw && raw.substr(0,2)==='% ');
      var rest  = (raw && raw.length>=2) ? raw.substr(2) : '';
      var rowBg = sel ? '#3a3d42' : '#202124';
      var prefixHtml = isCur
        ? '<span>% </span>'
        : '<span style="color:'+rowBg+'">% </span>'; // 非現在は背景と同色で見えなくする
      var row = '<div style="padding:2px 4px;'+(sel?'background:#3a3d42;color:#fff;':'')+'">'+ prefixHtml + escapeHtml(rest) +'</div>';
      html.push(row);
    }
    box.innerHTML=html.join('');
    box.style.display='block';
  }
  function hideCmdCompletions(){
    var box=document.getElementById('cmdcomplist');
    if(box) box.style.display='none';
  }
  // （置換）updateCmdCompletions（グローバル定義側）: head をコロン無しで保持
  function updateCmdCompletions(){
    var cmdEl=document.getElementById('cmdline'); if(!cmdEl) return;
    var raw = cmdEl.value.replace(/^:/,'');
    // :ls / :buffers → :b に変換して UI を出す
    if (/^(ls|buffers)\s*$/i.test(raw)){ cmdEl.value='b '; raw='b '; }
    // :b / :buffer の補完（バッファ一覧）
    var mB = raw.match(/^(b(uffer)?)\s*(.*)$/i);
    if (mB){
      var typed = mB[3] || '';
      var data = (typeof buildBufferCompletions==='function') ? buildBufferCompletions(typed) : {values:[],labels:[]};
      if (!data.values.length){ resetCmdCompl(); cmdCompl.head='b '; cmdCompl.typed=typed; return; }
      var idx = cmdCompl.index; if (!cmdCompl.active || idx==null || idx<0 || idx>=data.values.length) idx=0;
      cmdCompl.active=true; cmdCompl.list=data.values; cmdCompl.labels=data.labels; cmdCompl.index=idx; cmdCompl.head='b '; cmdCompl.typed=typed;
      showCmdCompletions(cmdCompl.list);
      return;
    }
    // 既存: :e / :e! のファイル補完
    var m = raw.match(/^(e!?)(\s+)(.*)$/i);
    if(!m){ resetCmdCompl(); return; }
    var head  = m[1] + m[2];
    var typed = m[3];
    var list = buildFileCompletions(typed);
    if(!list.length){ resetCmdCompl(); cmdCompl.head=head; cmdCompl.typed=typed; return; }
    var idx = cmdCompl.index;
    var needRecalc = (!cmdCompl.active || idx==null || idx<0 || idx>=list.length || (typed && list[idx].toLowerCase().indexOf(typed.toLowerCase())!==0));
    if (needRecalc){
      idx = -1;
      if (typed){
        var low = typed.toLowerCase();
        for (var i2=0;i2<list.length;i2++){ if (list[i2].toLowerCase().indexOf(low)===0){ idx=i2; break; } }
      }
      if (idx===-1) idx=0;
    }
    cmdCompl.active=true; cmdCompl.list=list; cmdCompl.labels=[]; cmdCompl.index=idx; cmdCompl.head=head; cmdCompl.typed=typed;
    showCmdCompletions(list);
  }
  function cycleCmdCompl(dir){
    if(!cmdCompl.active || !cmdCompl.list.length) return;
    var n = cmdCompl.list.length;
    cmdCompl.index = (cmdCompl.index + (dir<0?-1:1) + n) % n;
    applyCurrentCandidate();     // ← 移動するたびに入力欄へ反映
    showCmdCompletions(cmdCompl.list);
  }
  // （修正）commitCmdCompletion（グローバル定義側）内 colon 除去: value へ書く際に head から先頭コロンを除く
  function commitCmdCompletion(){
    if(!cmdCompl.active) return;
    applyCurrentCandidate(); // 既に入力欄へ反映されているので確定処理はこれだけ
  }
  // （追加）cmdCompl 関連関数群の中に挿入（resetCmdCompl() の直後など適所）
  function applyCurrentCandidate(){
    if(!cmdCompl.active) return;
    if(cmdCompl.index<0 || cmdCompl.index>=cmdCompl.list.length) return;
    var cmdEl = document.getElementById('cmdline');
    if(!cmdEl) return;
    var cand = cmdCompl.list[cmdCompl.index];
    // head は "e " / "e! " 形式（先頭コロン無し）
    cmdEl.value = cmdCompl.head + cand;
    // 反映後、カーソルを末尾へ
    cmdEl.selectionStart = cmdEl.selectionEnd = cmdEl.value.length;
  }
  function escapeHtml(s){
    return s.replace(/[&<>"']/g,function(c){
      return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]);
    });
  }
  // （追加）コマンドライン input / blur イベント（既存になければ追加）
  cmd.addEventListener('input', function(){
    updateCmdCompletions();
  });
  cmd.addEventListener('blur', function(){
    // フォーカス外れたら閉じる
    resetCmdCompl();
  });
  // === 起動引数（app.CommandLine）対応のヘルパーを追加 ===
function _getStartupArgFromApp(){
  try{
    var cl = '';
    if (window.app && (app.CommandLine || app.commandLine)){
      cl = String(app.CommandLine || app.commandLine || '');
    }
    var a = _parseCmdlineForArg(cl);
    if (a) return a;
  }catch(_){ }
  // WMI フォールバック
  return _getStartupArgFromWMI();
}
function _parseCmdlineForArg(cl){
  try{
    if (!cl) return null;
    var m = String(cl).match(/\.hta["']?\s+(.+)$/i);
    if (!m) return null;
    var rest = m[1].trim(); if (!rest) return null;
    if (rest.charAt(0)==='"'){ var m2 = rest.match(/^"([^"]+)"/); if (m2 && m2[1]) return m2[1]; }
    if (rest.charAt(0)==="'"){ var m3 = rest.match(/^'([^']+)'/); if (m3 && m3[1]) return m3[1]; }
    return rest.split(/\s+/)[0];
  }catch(_){ return null; }
}
function _getStartupArgFromWMI(){
  try{
    var svc = GetObject("winmgmts:root\\cimv2");
    var col = svc.ExecQuery("SELECT CommandLine FROM Win32_Process WHERE Name='mshta.exe'");
    var self = (typeof _htaPathWin==='function') ? _htaPathWin() : '';
    var e = new Enumerator(col);
    for (; !e.atEnd(); e.moveNext()){
      var it = e.item();
      var cmd = String(it.CommandLine||'');
      if (!self || cmd.toLowerCase().indexOf(self.toLowerCase())>=0){
        var a = _parseCmdlineForArg(cmd);
        if (a) return a;
      }
    }
  }catch(_){ }
  return null;
}
  function _htaPathWin(){
    try{
      var href = String(window.location.href||'');
      var m = href.match(/^file:\/\/\/(.*)$/i);
      var p = m ? m[1] : href;
      p = decodeURIComponent(p).replace(/\//g,'\\');
      // 先頭に余分な \ が付く場合を正規化
      p = p.replace(/^\\+([A-Za-z]:\\)/, '$1');
      return p;
    }catch(_){ return ''; }
  }
  function _resolveAgainstHtaDir(p){
    try{
      var fso = new ActiveXObject("Scripting.FileSystemObject");
      // 絶対パス/UNC/ルート相対はそのまま
      if (/^[A-Za-z]:\\/.test(p) || /^\\\\/.test(p) || /^[\\\/]/.test(p)) return p;
      var dir = fso.GetParentFolderName(_htaPathWin()) || '.';
      return fso.BuildPath(dir, p);
    }catch(_){ return p; }
  }
  function _openFileOrNewOnStartup(path){
    if(!path) return;
    try{ bufEnsureInitial(); bufOpenFile(path, false); } catch(e){ showMsg("Startup open failed", 1800); }
  }
  // 起動引数からのファイルオープン（app.CommandLine 対応）
  (function startupFileOpen(){
    try{
      var arg = _getStartupArgFromApp();
      if(!arg) return;
      var path = _resolveAgainstHtaDir(arg);
      _openFileOrNewOnStartup(path);
    }catch(e){}
  })();
})();
  function buildBufferCompletions(prefix){
    var vals=[], labels=[];
    try{
      var p = String(prefix||'').toLowerCase();
      for(var i=0;i<Buffers.list.length;i++){
        var b = Buffers.list[i];
        var id = String(b.id);
        var name = (_bufMakeName(b.path)||'[No Name]');
        var path = String(b.path||'');
        var cur = (i===Buffers.current)?'% ':'  ';
        var mod = (b.modifiedCount>0)?' [+]':'';
        var label = cur+' '+id+' '+name+(path?(' ('+path+')'):'')+mod;
        // フィルタ: id 前方一致 / name 前方一致 / path 前方一致（p 空なら全件）
        var lowName=name.toLowerCase(), lowPath=path.toLowerCase();
        if (!p || id.indexOf(p)===0 || lowName.indexOf(p)===0 || lowPath.indexOf(p)===0){
          vals.push(id); labels.push(label);
        }
      }
    }catch(_){ }
    return { values: vals, labels: labels };
  }
// インクリメンタルサーチ: /,? 入力中に1文字ごとに一時ジャンプ（確定は Enter、Esc で元に戻す）
function bindCmdlineIncSearch(){
  var cmd = document.getElementById('cmdline');
  if(!cmd || cmd._incBound) return;
  cmd.addEventListener('input', function(){
    try{
      var pre = document.getElementById('cmdprefix');
      var pfx = pre ? ((pre.innerText || pre.textContent) || '') : '';
      if (pfx !== '/' && pfx !== '?') return;
      try{ window._incsearchActive = true; }catch(_){ }
      var pat = cmd.value || '';
      var ed  = document.getElementById('editor');
      var fromPos = (typeof window._searchFromPos === 'number')
        ? window._searchFromPos
        : (ed ? getCaret(ed) : undefined);
      if (!pat){
        try{ clearIncPreview(); }catch(_){ }
        // 空なら元位置へ（確定はまだしない）
        if (ed && typeof window._searchFromPos === 'number'){
          var L = ed.value.length;
          setCaret(ed, Math.max(0, Math.min(L, window._searchFromPos)));
          updateStatus(ed);
        }
        return;
      }
      var dir = (pfx === '/') ? 1 : -1;
      // 直前の検索状態を退避（確定は Enter 時のみ）
      var prevPat = (window.searchState && searchState.pat) ? searchState.pat : '';
      var prevDir = (window.searchState && typeof searchState.dir==='number') ? searchState.dir : 1;
      // 一時ジャンプ（基準方向は更新しない・包含開始）
// early-shrink (anchor): same anchor still matches -> shrink preview length only and return
try{
  if (window._incPrevPos && ed && typeof pat === "string" && pat.length > 0){
    var t0 = ed.value || "";
    var abs0 = lineStartByNumber(t0, window._incPrevPos.line) + (window._incPrevPos.col - 1);
    if (abs0 >= 0 && abs0 + pat.length <= t0.length && t0.substr(abs0, pat.length) === pat){
      window._incPrevPos.len = pat.length;
      _repositionIncPreviewRange();
      try{ setSelection(ed, abs0, abs0 + pat.length); }catch(_){ }
      // keep focus on cmdline
      try{
        if (document.activeElement !== cmd){
          cmd.focus();
          var v0 = cmd.value || "";
          if (cmd.setSelectionRange) cmd.setSelectionRange(v0.length, v0.length);
        }
      }catch(_){}
      // doSearch を呼ばないので n/N の基準を復元してから終了
      try{ searchState.pat = prevPat; searchState.dir = prevDir; }catch(_){}
      try{ window._incLastMiss = false; }catch(_){}
      return;
    }
  }
}catch(_){}
      doSearch(pat, dir, fromPos, { updateBase: false, inclusive: true, incPreview: true });
      // incshrink: sync overlay length with current pattern on every input
      try{
        if (window._incPrevPos && typeof pat === 'string'){
          window._incPrevPos.len = pat.length;
          _repositionIncPreviewRange();
        }
      }catch(_){ }
      // shrink-by-lastidx: always resize preview to current pattern length (no focus shift)
      try{
        if (typeof window._incLastIdx === 'number'){
          var __t = ed ? (ed.value||'') : '';
          var __s = window._incLastIdx;
          if (__s>=0 && __s<=__t.length){
            var __lc = getLineCol(__t, __s);
            window._incPrevPos = { line: __lc.line, col: __lc.col, len: (pat ? pat.length : 0) };
            _repositionIncPreviewRange();
          }
        }
      }catch(_){ }
      if (window._incLastHit){
      // shrink-follow: adjust selection and preview to pat length
      try{
        if (ed && typeof pat==='string'){
          var s = (typeof ed.selectionStart==='number') ? ed.selectionStart : (typeof getCaret==='function'?getCaret(ed):0);
          var T = ed.value || '';
          if (s>=0 && s<=T.length){
            setSelection(ed, s, Math.min(T.length, s + pat.length));
            var lcS = getLineCol(T, s);
            window._incPrevPos = { line: lcS.line, col: lcS.col, len: pat.length };
            _repositionIncPreviewRange();
          }
        }
      }catch(_){ }
      }
      // 入力ごとにフォーカスが editor に移った場合でも cmdline に戻す
      try{
        if (document.activeElement !== cmd){
          cmd.focus();
          var v = cmd.value || '';
          if (cmd.setSelectionRange) cmd.setSelectionRange(v.length, v.length);
        }
      }catch(_){ }
      // 直前の状態へ戻す（n/N の基準を汚さない）
      try{ searchState.pat = prevPat; searchState.dir = prevDir; }catch(_){}
      if (window._incLastHit){
      // force: preview length follows current pattern length on every input
      try{
        if (window._incPrevPos && typeof pat === 'string'){
          window._incPrevPos.len = pat.length;
          _repositionIncPreviewRange();
        }
      }catch(_){ }
      }
      if (window._incLastHit){
      // incsearch: shrink preview to current pattern length if selection matches
      try{
        if (ed && pat){
          var s = (typeof ed.selectionStart==='number') ? ed.selectionStart : (typeof getCaret==='function'?getCaret(ed):0);
          var e = (typeof ed.selectionEnd==='number') ? ed.selectionEnd   : s;
          var T = ed.value || '';
          if (s>=0 && e>=s && e<=T.length){
            if (T.substr(s, pat.length) === pat){
              var lc3 = getLineCol(T, s);
              renderIncPreviewRange(lc3.line, lc3.col, pat.length);
            }
          }
        }
      }catch(_){ }
      }
      try{
        if (window._incLastMiss){
          var t = ed ? ed.value : "";
          if (t && pat){
            var start = (typeof fromPos === "number") ? fromPos : 0;
            var idx2;
            if (dir >= 0){
              idx2 = t.indexOf(pat, start);
              if (idx2 < 0) idx2 = t.indexOf(pat, 0);
            }else{
              var anchor = start; if (anchor < 0) anchor = 0; if (anchor > t.length) anchor = t.length;
              idx2 = t.lastIndexOf(pat, anchor);
              if (idx2 < 0) idx2 = t.lastIndexOf(pat);
            }
            if (idx2 >= 0){
              try{
                var lc2 = getLineCol(t, idx2);
                renderIncPreviewRange(lc2.line, lc2.col, pat.length);
                setSelection(ed, idx2, idx2 + pat.length);
                setCaret(ed, idx2);
                updateStatus(ed);
              }catch(_){}
              window._incLastMiss = false;
            // keep focus on cmdline after revival
            try{
              var __cmd = document.getElementById("cmdline");
              if (__cmd && document.activeElement !== __cmd){
                __cmd.focus();
                var __v = __cmd.value || "";
                if (__cmd.setSelectionRange) __cmd.setSelectionRange(__v.length, __v.length);
              }
            }catch(_){ }
            }
          }
        }
      }catch(_){}
    }catch(_){}
      // incshrink-final: enforce overlay len at end of input
      try{
        if (typeof pat === 'string' && window._incPrevPos){
          window._incPrevPos.len = pat.length;
          _repositionIncPreviewRange();
        }
      }catch(_){ }
  });
  cmd._incBound = true;
}
// incsearch プレビュー用オーバーレイ（行全体を半透明で強調）
function ensureIncPreviewLayer(){
  if (window._incPrevLayer) return window._incPrevLayer;
  var ed = document.getElementById('editor');
  if (!ed) return null;
  var layer = document.createElement('div');
  layer.id = 'incprev-layer';
  layer.style.position = 'absolute';
  layer.style.pointerEvents = 'none';
  layer.style.display = 'none';
  layer.style.background = 'rgba(120,160,255,0.30)'; // VISUAL 相当の色味
  layer.style.border = '0';
  layer.style.boxSizing = 'content-box';
  layer.style.zIndex = 10;
  document.body.appendChild(layer);
  // スクロールで位置追従
  if (!window._incPrevScrollBound){
    try{
      ed.addEventListener('scroll', function(){
        if (layer.style.display !== 'none'){ try{ _repositionIncPreviewRange(); }catch(_){ } }
      });
      window._incPrevScrollBound = true;
    }catch(_){}
  }
  window._incPrevLayer = layer;
  return layer;
}
function getCharWidthPx(ed){
  try{
    if (typeof window._charWidthPx === 'number' && window._charWidthPx > 0) return window._charWidthPx;
    var s = ed && (ed.currentStyle || (window.getComputedStyle ? window.getComputedStyle(ed, null) : null));
    var ff = s ? (s.fontFamily || s.fontfamily || 'monospace') : 'monospace';
    var fs = s ? (s.fontSize   || s.fontsize   || '21px')      : '21px';
    var ls = 0;
    try{
      var lsRaw = s && (s.letterSpacing || s['letter-spacing']);
      if (lsRaw && lsRaw !== 'normal') ls = parseFloat(lsRaw) || 0;
    }catch(_){}
    var span = document.createElement('span');
    span.style.position    = 'absolute';
    span.style.visibility  = 'hidden';
    span.style.whiteSpace  = 'pre';
    span.style.fontFamily  = ff;
    span.style.fontSize    = fs;
    if (ls) span.style.letterSpacing = (ls + 'px');
    var count = 200;
    var sample = Array(count + 1).join('0'); // 等幅前提、平均化
    span.innerText = sample;
    document.body.appendChild(span);
    var w = span.offsetWidth / count;
    document.body.removeChild(span);
    if (ls) w += ls;
    window._charWidthPx = (w && isFinite(w) && w > 0) ? w : 8;
    return window._charWidthPx;
  }catch(_){ return 8; }
}
// 内部状態: 表示中の line/col/len
window._incUseTextRange = false;  // force fallback width calc (charWidth * len)
function _repositionIncPreviewRange(){
  var layer = window._incPrevLayer;
  if (!layer) return;
  var ed = document.getElementById('editor');
  if (!ed || typeof window._incPrevPos !== 'object') return;
  var lh = getLineHeightPx(ed);
  if (!lh || !isFinite(lh) || lh <= 0) { layer.style.display = 'none'; return; }
  var line = parseInt((window._incPrevPos.line||1),10) || 1;
  var col  = parseInt((window._incPrevPos.col ||1),10) || 1;
  var len  = parseInt((window._incPrevPos.len ||0),10); if (!isFinite(len) || len < 0) len = 0;
  // 可能なら IE の TextRange で実座標を取得（最も正確）
  try{
    if (ed.createTextRange){
      var text = String(ed.value || "");
      var absStart = 0;
      try{
        absStart = lineStartByNumber(text, line) + (col - 1);
      }catch(_){ absStart = 0; }
      if (absStart < 0) absStart = 0;
      if (absStart > text.length) absStart = text.length;
      var tr = ed.createTextRange();
      tr.collapse(true);
      tr.moveStart('character', absStart);
      tr.moveEnd('character', len > 0 ? len : 0);
      var rc = tr.getBoundingClientRect();
      if (rc && isFinite(rc.left) && isFinite(rc.right) && isFinite(rc.top) && isFinite(rc.bottom)){
        var cw2 = getCharWidthPx(ed);
        var w = Math.max(1, Math.round(cw2 * Math.max(0, len)));
        var h = Math.max(1, rc.bottom - rc.top);
        layer.style.left   = rc.left + 'px';
        layer.style.top    = rc.top  + 'px';
        layer.style.width  = w + 'px';
        layer.style.height = h + 'px';
        layer.style.display = 'block';
        return;
      }
    }
  }catch(_){}
  // フォールバック（文字幅×列 + パディング/ボーダ補正）
  var cw = getCharWidthPx(ed);
  var r  = ed.getBoundingClientRect();
  var cs = ed.currentStyle || (window.getComputedStyle ? window.getComputedStyle(ed, null) : null);
  var padL=0,padT=0,borL=0,borT=0;
  try{
    padL = parseFloat((cs && (cs.paddingLeft || cs['padding-left'])) || 0) || 0;
    padT = parseFloat((cs && (cs.paddingTop  || cs['padding-top']))  || 0) || 0;
    borL = parseFloat((cs && (cs.borderLeftWidth || cs['border-left-width'])) || 0);
    borT = parseFloat((cs && (cs.borderTopWidth  || cs['border-top-width']))  || 0);
    if (!isFinite(borL)) borL = ed.clientLeft || 0;
    if (!isFinite(borT)) borT = ed.clientTop  || 0;
  }catch(_){ borL = ed.clientLeft || 0; borT = ed.clientTop || 0; }
  var contentLeft = r.left + borL + padL;
  var contentTop  = r.top  + borT + padT;
  var startCol = (col - 1);
  var endCol   = (col - 1 + len);
  var startOff = Math.floor(startCol * cw + 0.01);
  var endOff   = Math.ceil(endCol   * cw - 0.01);
  var top  = contentTop  + (line - 1) * lh - ed.scrollTop;
  var left = contentLeft + startOff    - ed.scrollLeft;
  var wid  = Math.max(1, endOff - startOff);
  layer.style.left   = left + 'px';
  layer.style.top    = top  + 'px';
  layer.style.width  = wid  + 'px';
  layer.style.height = Math.round(lh) + 'px';
  layer.style.display = 'block';
}
function renderIncPreviewRange(line, col, len){
  var ed = document.getElementById('editor');
  if (!ed) return;
  ensureIncPreviewLayer();
  window._incPrevPos = { line: line, col: col, len: len };
  _repositionIncPreviewRange();
  if (window._incPrevLayer) window._incPrevLayer.style.display = 'block';
}
function clearIncPreview(){
  window._incPrevPos = undefined;
  if (window._incPrevLayer) window._incPrevLayer.style.display = 'none';
}
</script>
</body>
<script type="text/javascript">
// incsearch addon (safe inject, no core edits)
(function(){
  if (window._incsearchPatched) return;
  window._incsearchPatched = true;
  function ensureBindInc(){
    try{
      var cmd = document.getElementById('cmdline');
      if (!cmd || cmd._incBound) return;
      // 入力ごとに暫定ジャンプ（基準は汚さない）
      cmd.addEventListener('input', function(){
        try{
          var pre = document.getElementById('cmdprefix');
          var pfx = pre ? ((pre.innerText || pre.textContent) || '') : '';
          if (pfx !== '/' && pfx !== '?') return;
          window._incsearchActive = true;
          var pat = cmd.value || '';
          var ed  = document.getElementById('editor');
          if (!pat){
            try{ if (typeof clearIncPreview==='function') clearIncPreview(); }catch(e){}
            return;
          }
          var dir = (pfx === '/') ? 1 : -1;
          // 検索基準は保存/復元して n/N の挙動を汚さない
          var prevPat = (window.searchState && searchState.pat) ? searchState.pat : '';
          var prevDir = (window.searchState && typeof searchState.dir==='number') ? searchState.dir : 1;
          var fromPos = (typeof window._searchFromPos === 'number')
            ? window._searchFromPos
            : (ed && typeof getCaret==='function' ? getCaret(ed) : 0);
          if (typeof doSearch === 'function'){
            doSearch(pat, dir, fromPos, { updateBase:false, inclusive:true, incPreview:true });
          }
          // フォーカス維持
          if (document.activeElement !== cmd){
            cmd.focus();
            var v = cmd.value || '';
            if (cmd.setSelectionRange) cmd.setSelectionRange(v.length, v.length);
          }
          try{ searchState.pat = prevPat; searchState.dir = prevDir; }catch(e){}
        }catch(e){}
      });
      // Esc で解除（プレビュー消去）
      cmd.addEventListener('keydown', function(ev){
        var k = ev.keyCode || ev.which;
        if (k === 27){
          window._incsearchActive = false;
          try{ if (typeof clearIncPreview==='function') clearIncPreview(); }catch(e){}
        }
      });
      cmd._incBound = true;
    }catch(e){}
  }
  // openSearchBar 後にバインド
  (function(){
    var _open = window.openSearchBar;
    if (typeof _open === 'function'){
      window.openSearchBar = function(dir){
        var r = _open.apply(this, arguments);
        try{ setTimeout(ensureBindInc, 0); }catch(e){}
        return r;
      };
    }else{
      setTimeout(ensureBindInc, 500);
    }
  })();
  // runCommand 確定時は incsearch フラグを下ろす（未ヒットならここでメッセージ許可）
  (function(){
    var _run = window.runCommand;
    if (typeof _run === 'function'){
      window.runCommand = function(cmd){
        try{ window._incsearchActive = false; }catch(e){}
        return _run.apply(this, arguments);
      };
    }
  })();
  // showMsg をラップして、incsearch 中の "Pattern not found" を抑止
  (function(){
    if (!window._showMsgOrig && typeof window.showMsg === 'function'){
      window._showMsgOrig = window.showMsg;
      window.showMsg = function(s, cls, ms){
        try{
          if (window._incsearchActive && typeof s === 'string'){
            var t = s.toLowerCase ? s.toLowerCase() : String(s);
            if (t.indexOf('pattern not found') >= 0){
              return; // 抑止
            }
          }
        }catch(e){}
        return window._showMsgOrig.apply(this, arguments);
      };
    }
  })();
})();
</script>
<script type="text/javascript">
</script>
<script type="text/javascript">
</script>
<script type="text/javascript">
</script>
<script type="text/javascript">
</script>
<script type="text/javascript">
</script>
<script type="text/javascript">
/* DND_OPEN_IE10_HTA */
(function enableDndOpen(){
  // 診断フラグ（必要時 true に）
  window._DND_DEBUG = false;
  function dbg(s){ try{ if (window._DND_DEBUG) showMsg(String(s), 1600); }catch(_){ } }
  function normalizeDropPath(p){
    if(!p) return "";
    p = String(p).replace(/^\s+|\s+$/g, "");
    if (p.charAt(0)==='"' && p.charAt(p.length-1)==='"') p=p.slice(1,-1);
    // file:///C:/path → C:\path
    var m1 = p.match(/^file:\/\/\/(.*)$/i);
    if (m1){ var q = decodeURIComponent(m1[1]).replace(/\//g, "\\"); q = q.replace(/^\\+([A-Za-z]:\\)/, "$1"); return q; }
    // file://server/share/path → \\server\share\path
    var m2 = p.match(/^file:\/\/([^\/]+)\/(.*)$/i);
    if (m2){ var host=m2[1]; var rest=decodeURIComponent(m2[2]).replace(/\//g, "\\"); return "\\\\"+host+"\\"+rest.replace(/^\\+/, ""); }
    return p;
  }
  function getDropPaths(ev){
    var we = window.event;
    var dt = (ev && ev.dataTransfer) || (we && we.dataTransfer) || null;
    var outP = []; if (!dt) return outP;
    function pushParts(s){
      if (!s) return;
      var parts = String(s).split(/\u0000|\r?\n/);
      for (var i=0;i<parts.length;i++){
        var t = String(parts[i]).replace(/^\s+|\s+$/g, "");
        if (t){ var p = normalizeDropPath(t); if (p) outP.push(p); }
      }
    }
    function tryGet(fmt){ try{ if (dt.getData){ var s = dt.getData(fmt); if (s) pushParts(s); } }catch(_){ } }
    // IE 独自（最優先）
    tryGet("FileNameW"); if (!outP.length) tryGet("FileName");
    // URL/テキスト各種
    if (!outP.length) tryGet("URL");
    if (!outP.length) tryGet("UniformResourceLocatorW");
    if (!outP.length) tryGet("UniformResourceLocator");
    if (!outP.length) tryGet("text/uri-list");
    if (!outP.length) tryGet("Text");
    if (!outP.length) tryGet("text");
    if (!outP.length) tryGet("text/plain");
    // 診断
    if (!outP.length && window._DND_DEBUG){
      try{
        var fmts=["FileNameW","FileName","URL","UniformResourceLocatorW","UniformResourceLocator","text/uri-list","Text","text","text/plain"];
        var logs=[], typesStr="", filesLen=0;
        for(var k=0;k<fmts.length;k++){ var v=""; try{ v=dt.getData(fmts[k])||""; }catch(__){}; logs.push(fmts[k]+":"+(v?"Y":"-")); }
        try{ if (dt.types && dt.types.length){ typesStr=(dt.types.join?dt.types.join(","):String(dt.types)); } }catch(__){}
        try{ filesLen = (dt.files && typeof dt.files.length==="number")?dt.files.length:0; }catch(__){}
        dbg("types=["+typesStr+"] files="+filesLen+" | "+logs.join(" "));
      }catch(_){ }
    }
    return outP;
  }
  // パスが取れない時のフォールバック: FileReader で中身を開く（無名バッファ）
  function openDroppedFilesByReader(fileList){
    if (!fileList || !fileList.length){ try{ showMsg("ドロップからパスを取得できません", 1400); }catch(_){ } return; }
    var ok=0, fail=0;
    for (var i=0;i<fileList.length;i++){
      (function(f){
        try{
          if (!window.FileReader){ fail++; return; }
          var fr = new FileReader();
          fr.onload = function(){
            try{
              var t = String(fr.result||"").replace(/\r\n?/g, "\n");
              try{ bufEnsureInitial(); }catch(_){ }
              var name = (f && f.name) ? String(f.name) : "[Drop]";
              if (typeof bufCreate === 'function'){
                var idx = bufCreate({ path: '', text: t, dispName: name });
                if (idx>=0 && typeof bufSwitchToIndex === 'function') bufSwitchToIndex(idx);
              } else {
                var ed = document.getElementById('editor'); if (ed){ ed.value = t; try{ setBaseline(t); }catch(_){ } }
              }
              ok++;
            }catch(__){ fail++; }
          };
          fr.onerror = function(){ fail++; };
          fr.readAsText(f);
        }catch(__){ fail++; }
      })(fileList[i]);
    }
    setTimeout(function(){
      try{
        if (ok>0 && fail===0) showMsgAuto("Dropped: "+ok+" file(s) loaded (reader)", 1800);
        else if (ok>0 && fail>0) showMsgAuto("Dropped: "+ok+" loaded, "+fail+" failed (reader)", 1800);
        else showMsg("ドロップからパスを取得できません", 1400);
      }catch(_){ }
    }, 30);
  }
  function preventAll(e){
    try{ e.preventDefault(); }catch(_){ }
    try{ e.stopPropagation(); }catch(_){ }
    try{ e.returnValue = false; }catch(_){ }
    try{ e.cancelBubble = true; }catch(_){ }
    return false;
  }
  function bindPhases(target, type, handler){
    try{ target.addEventListener(type, handler, false); }catch(_){ }
    try{ target.addEventListener(type, handler, true ); }catch(_){ }
  }
  function bindDnD(target){
    if (!target || target._dndBound) return;
    var onEnter = function(e){ try{ if (e.dataTransfer){ e.dataTransfer.dropEffect = 'copy'; e.dataTransfer.effectAllowed = 'copy'; } }catch(_){ } return preventAll(e); };
    var onOver  = function(e){ try{ if (e.dataTransfer){ e.dataTransfer.dropEffect = 'copy'; e.dataTransfer.effectAllowed = 'copy'; } }catch(_){ } return preventAll(e); };
    var onDrop  = function(e){
      try{
        preventAll(e);
        var we = window.event;
        var dt = (e && e.dataTransfer) || (we && we.dataTransfer) || null;
        var paths = getDropPaths(e) || [];
        if (paths && paths.length){
          try{ bufEnsureInitial(); }catch(_){ }
          for (var i=0;i<paths.length;i++){
            var p = paths[i]; if (!p) continue;
            // if (!/\.txt$/i.test(p)) continue; // .txt のみに制限する場合は有効化
            try{ var fso=new ActiveXObject('Scripting.FileSystemObject'); if (fso.FileExists(p)){ bufOpenFile(p, false); } }
            catch(__){ try{ bufOpenFile(p, false); }catch(___){ } }
          }
          return false;
        }
        // パス無し → FileReader フォールバック
        try{ if (dt && dt.files && typeof dt.files.length==='number' && dt.files.length>0){ openDroppedFilesByReader(dt.files); return false; } }catch(__){ }
        // 取得不可の最終通知（簡易診断付き）
        try{
          var typesStr=""; try{ if (dt && dt.types){ typesStr=(dt.types.join?dt.types.join(','):String(dt.types)); } }catch(__){}
          var filesLen=0; try{ filesLen=(dt && dt.files && typeof dt.files.length==='number')?dt.files.length:0; }catch(__){}
          showMsg('ドロップからパスを取得できません [types='+typesStr+' files='+filesLen+']', 1800);
        }catch(__){ showMsg('ドロップからパスを取得できません', 1400); }
      }catch(_){ }
      return false;
    };
    bindPhases(target, 'dragenter', onEnter);
    bindPhases(target, 'dragover',  onOver );
    bindPhases(target, 'drop',      onDrop );
    target._dndBound = true;
  }
  function legacyBlock(){
    try{
      document.ondragenter = function(){ try{ event.returnValue=false; }catch(_){ } return false; };
      document.ondragover  = function(){ try{ event.returnValue=false; }catch(_){ } return false; };
      document.ondrop      = function(){ try{ event.returnValue=false; }catch(_){ } return false; };
      window.ondragover    = function(){ try{ event.returnValue=false; }catch(_){ } return false; };
      window.ondrop        = function(){ try{ event.returnValue=false; }catch(_){ } return false; };
    }catch(_){ }
  }
  function lateBind(){
    try{
      var ed=document.getElementById('editor');
      if(!ed || typeof bufOpenFile!=='function' || typeof bufEnsureInitial!=='function'){ setTimeout(lateBind, 80); return; }
      legacyBlock();
      bindDnD(ed); bindDnD(document.body); bindDnD(document);
      try{ bindDnD(window); }catch(_){ }
    }catch(_){ setTimeout(lateBind, 120); }
  }
  lateBind();
})();
 /* END DND_OPEN_IE10_HTA */
</script>
<script type="text/javascript"> /* PATCH:noname-tint */
(function(){
  if (typeof updateStatus !== 'function') return;
  var _origUpdateStatus = updateStatus;
  window.updateStatus = function(){
    try{ _origUpdateStatus.apply(this, arguments); }catch(_){ }
    try{
      var el = document.getElementById('filename'); if(!el) return;
      var isNoPath=false, nameShown='[No Name]', bprefix='';
      if (typeof Buffers==='object' && typeof Buffers.current==='number' && Buffers.current>=0){
        var b = Buffers.list && Buffers.list[Buffers.current];
        if (b){
          bprefix = '[' + b.id + '] ';
          isNoPath = !b.path;
          if (isNoPath){
            nameShown = (b.dispName && String(b.dispName)) || '[No Name]';
          } else {
            nameShown = (window._currentFile && String(window._currentFile)) || '[No Name]';
          }
        }
      } else {
        nameShown = (window._currentFile && String(window._currentFile)) || '[No Name]';
        isNoPath = !window._currentFile;
      }
      el.innerText = bprefix + nameShown;
            var col = '#ddd';
            if (isNoPath){
              if (typeof b !== 'undefined' && b && b.dispName) col = 'DarkCyan';
              else col = '#e28';
            }
            try{ el.style.color = col; }catch(_){ }
    }catch(_){ }
  };
})();
</script>
</html>
