<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=11">
<title>Vi-like Text Editor "tedit" v0.3.3 (paste+help)</title>

<hta:application
  id="app"
  applicationname="tedit"
  border="thin"
  caption="yes"
  sysmenu="yes"
  singleinstance="yes"
  scroll="no"
/>

<style>
  html, body {
    height: 100%;
    margin: 0;
    background: #1e1f22;
    color: #ddd;
    font-family: Consolas, "Courier New", monospace;
  }
  #pane { position: relative; height: 100%; }

  /* 行番号ガター */
  #gutter {
    position: absolute; top: 0; bottom: 0; left: 0;
    width: 72px; background: #1b1c1f; border-right: 1px solid #3b3d42;
    color: #c0c0c0; text-align: right; padding-right: 8px; box-sizing: border-box;
    font-size: 21px; line-height: 1.6; pointer-events: none; overflow: hidden;
    z-index: 2; /* ←追加 */
  }
  #gutter .ln { height: 1.6em; }

  /* 本文 */
  #editor {
    position: absolute; top: 0; bottom: 0; right: 0; left: 0;
    width: 100%; height: 100%;
    box-sizing: border-box; padding: 10px; padding-left: 82px; /* number=on */
    background: #1e1f22; color: #ddd; border: none; outline: none; resize: none;
    font-size: 21px; line-height: 1.6; caret-color: #fff;
  }

  /* コマンドバー（:） */
  #cmdbar {
    position: absolute; left: 0; right: 0; bottom: 0;
    height: 64px;
    background: #222; color: #fff;
    border-top: 1px solid #3b3d42; font-size: 14px;
    display: flex; flex-direction: column; z-index: 10;
  }
  #statusline1 {
    display: flex;
    align-items: center;
    width: 100%;
    height: 28px;
    overflow: hidden;
  }
  #filename, #modmark, #mode, #pos {
    flex: 0 0 auto;
    min-width: 80px;
    max-width: 160px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  #hint {
    flex: 1 1 auto;
    text-align: center;
    min-width: 120px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  #cmdprefix, #cmdline {
    position: static;
    font-size: 14px;
    height: 28px;
    margin: 0;
    background: #232323;
    color: #fff;
    border: none;
    box-sizing: border-box;
    display: inline-block;
    vertical-align: middle;
  }
  #cmdline {
    width: calc(100% - 32px);
    padding: 4px 12px;
    border: 1px solid #3b3d42;
    color: #fff;
    background: #232323;
    outline: none;
    font-family: inherit;
    margin-left: 0;
    margin-right: 0;
    display: none;
    height: 28px;
  }
  #cmdmsg {
    display: none;
    position: absolute;
    left: 0; top: 0; width: 100%; height: 100%;
    background: #232323; color: #ffd;
    font-size: 14px;
    padding: 4px 12px;
    box-sizing: border-box;
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    z-index: 12;
    height: 28px;
  }

  /* ヘルプオーバーレイ */
  #help {
    position: absolute; left: 5%; right: 5%; top: 8%; bottom: 8%;
    border: 1px solid #3b3d42; background: rgba(30,31,34,0.98);
    display: none; z-index: 4; box-shadow: 0 8px 24px rgba(0,0,0,.4);
    padding: 16px; overflow: auto; font-size: 14px; line-height: 1.6;
  }
  #help h2 { margin: 0 0 8px; font-size: 16px; }
  #help kbd {
    background: #444; color: #fff; padding: 1px 4px; border-radius: 3px; font-size: 12px;
  }
  #help pre { background:#15161a; padding:8px; overflow:auto; }

  /* ちょいメッセージ（右下トースト） */
  #msg {
    position: absolute; right: 12px; bottom: 40px; z-index: 5;
    background: #2b2d31; border: 1px solid #3b3d42; color: #ddd;
    padding: 6px 10px; border-radius: 4px; font-size: 12px; display: none;
  }

  /* ステータスバー */
  #statusbar {
    position: absolute; left: 0; right: 0; bottom: 0;
    height: 28px; background: #222; color: #fff;
    border-top: 1px solid #3b3d42; font-size: 14px;
    display: flex; align-items: center; padding-left: 12px; z-index: 10;
  }
  #statusline2 {
    width: 100%;
    height: 28px;
    border-top: 2px solid #555;
    background: #232323;
    position: relative;
    z-index: 11;
    display: flex;
    align-items: center;
    justify-content: center;
  }
</style>
</head>
<body>
  <!-- 画面下部コマンド/ステータス/メッセージバー（統合） -->
  <div id="cmdbar" tabindex="0">
    <div id="statusline1">
      <span id="filename"></span>
      <span id="modmark"></span>
      <span id="mode"></span>
      <span id="pos"></span>
      <span id="hint"></span>
    </div>
    <div id="statusline2">
      <div id="cmdmsg" style="display:none;"></div>
      <span id="cmdprefix" style="display:none">:</span>
      <input id="cmdline" type="text" style="display:none" />
    </div>
  </div>

  <div id="pane">
    <div id="gutter"></div>
    <textarea id="editor" spellcheck="false" wrap="off"
      placeholder="ここにテキストを入力…&#10;NORMALでは h j k l / w b / ^ などで移動。&#10;i で INSERT、Esc で NORMAL。&#10;:set number / :set nonumber / :help が使えます。"></textarea>
  </div>

  <!-- ヘルプ（最小の“使えるコマンド一覧”） -->
  <div id="help">
    <h2>使えるコマンド（最小）</h2>
    <p>
      <strong>モード</strong>： <kbd>i</kbd> INSERT / <kbd>v</kbd> VISUAL / <kbd>Esc</kbd> NORMAL<br>
      <strong>移動</strong>： <kbd>h</kbd><kbd>j</kbd><kbd>k</kbd><kbd>l</kbd>、<kbd>w</kbd>/<kbd>b</kbd>、<kbd>^</kbd>/<kbd>0</kbd>/<kbd>$</kbd>、<kbd>{</kbd>/<kbd>}</kbd><br>
      <strong>Emacs風</strong>： <kbd>Ctrl+P</kbd>/<kbd>N</kbd>/<kbd>F</kbd>/<kbd>B</kbd><br>
      <strong>行番号</strong>： <code>:set number</code> / <code>:set nonumber</code><br>
      <strong>ヘルプ</strong>： <kbd>F1</kbd> or <code>:help</code><br>
      <strong>ペースト</strong>：INSERT で <kbd>Ctrl+V</kbd>（改行は LF に正規化）／NORMAL では貼り付け不可
    </p>
    <hr>
    <p>今後追加予定（v1）：<br>
      編集：<code>i a o O</code>、<code>x</code>、<code>dd</code>、<code>d{motion}</code>、<code>c{motion}</code>、<code>cc</code>、<code>yy</code>、<code>y{motion}</code>、<code>p/P</code>、<code>.</code>、カウント<br>
      Ex：<code>:w</code> <code>:q</code> <code>:wq</code> <code>:q!</code> <code>ZZ</code>（UTF-8 / LF）<br>
      クリップボード：<code>:set clipboard=os|internal</code>
    </p>
    <p style="text-align:right"><button onclick="hideHelp()">閉じる (Esc)</button></p>
  </div>

  <div id="msg"></div>

<script>
// ====== オプション（:set 相当） ======
var OPT = {
  number: true,          // 行番号
  fileformat: 'unix',    // v1は LF 固定 ('unix')。将来 'dos' なら CRLF 正規化へ
  clipboard: 'internal'  // 'internal' or 'os'（y/d 実装時に反映）
};

var modifiedCount = 0;           // 0 = クリーン (>0 = 変更あり)
var baselineText = '';           // 保存/読込直後の内容
var UNDO_MAX = 200;
var undoStack = [];
var insertSessionActive = false;

function updateModifiedFlag(){
  // 互換用 (古いコードで参照している可能性あり)
  window.modified = (modifiedCount > 0);
}

function setBaseline(text){
  baselineText = text;
  modifiedCount = 0;
  updateModifiedFlag();
}

function pushUndo(reason){
  var ed = document.getElementById('editor');
  if(!ed) return;
  // 内容同一ならスキップ
  if (undoStack.length && undoStack[undoStack.length-1].text === ed.value) return;
  undoStack.push({
    text: ed.value,
    pos: getCaret(ed),
    reason: reason||'',
    mcount: modifiedCount
  });
  if (undoStack.length > UNDO_MAX) undoStack.shift();
}

function doUndo(){
  var ed = document.getElementById('editor');
  if(!ed || !undoStack.length){
    if (typeof showMsg === 'function') showMsg('No undo', 800);
    return;
  }
  var snap = undoStack.pop();
  ed.value = snap.text;
  setCaret(ed, Math.min(snap.pos, ed.value.length));
  // 過去状態の modifiedCount を復元
  modifiedCount = snap.mcount || 0;
  // ベースラインと一致しているなら 0 に強制（安全）
  if (ed.value === baselineText) modifiedCount = 0;
  updateModifiedFlag();
  insertSessionActive = false;
  if (typeof updateStatus==='function') updateStatus(ed);
  if (typeof ensureScrolloff==='function') ensureScrolloff(ed);
  if (typeof updateGutter==='function') updateGutter();
}

// ====== 基本ユーティリティ ======
function getCaret(editor){
  if (editor && typeof editor.selectionStart === 'number'){
    // VISUAL中は選択のアクティブ端（右端）を基準にする
    if (mode === MODE_VISUAL && editor.selectionStart !== editor.selectionEnd){
      return editor.selectionEnd;
    }
    return editor.selectionStart;
  }
  return 0;
}

// VISUAL時は移動方向ごとに基準端を選ぶ（左/上=selectionStart、右/下=selectionEnd）
function getActivePosForDir(editor, dir){
  // VISUAL中は“アクティブ端”を優先（直前モーションで動いた側を基準にする）
  if (mode === MODE_VISUAL && editor.selectionStart !== editor.selectionEnd){
    if (visActiveEnd === 'start') return editor.selectionStart;
    if (visActiveEnd === 'end')   return editor.selectionEnd;
    // フォールバック（未設定時のみ方向で判定）
    return (dir === 'left' || dir === 'up') ? editor.selectionStart : editor.selectionEnd;
  }
  return getCaret(editor);
}

function setCaret(editor,pos){ pos=Math.max(0,Math.min(editor.value.length,pos));
  if (editor.setSelectionRange){ editor.setSelectionRange(pos,pos); return; }
  var r=editor.createTextRange(); r.collapse(true); r.move('character',pos); r.select(); }
function setSelection(editor,a,b){ var s=Math.max(0,Math.min(a,b)), e=Math.max(0,Math.max(a,b));
  if (editor.setSelectionRange){ editor.setSelectionRange(s,e); return; }
  var r=editor.createTextRange(); r.collapse(true); r.moveStart('character',s); r.moveEnd('character',e-s); r.select(); }
function lineStartIndex(text,pos){ return text.lastIndexOf('\n', Math.max(0,pos-1)) + 1; }
function lineEndIndex(text,pos){ var i=text.indexOf('\n', pos); return (i===-1)?text.length:i; }
function getLineCol(text,pos){ var s=lineStartIndex(text,pos); return { line: text.slice(0,pos).split('\n').length, col: pos - s + 1 }; }
function getLineHeightPx(editor){ var cs = window.getComputedStyle?getComputedStyle(editor):editor.currentStyle;
  var lh=parseFloat(cs.lineHeight); if(!lh||isNaN(lh)){ var fs=parseFloat(cs.fontSize)||21; lh=Math.round(fs*1.6); } return lh; }
function isSpace(ch){ return ch===' '||ch==='\t'||ch==='\u3000'; }
function firstNonBlankPos(text,pos){ var s=lineStartIndex(text,pos), e=lineEndIndex(text,pos), i=s; while(i<e && isSpace(text[i])) i++; return i; }

// 追加/置換: 行数関連ユーティリティ（末尾改行は余分に数えない）
function totalLines(text){
  if(!text || text.length===0) return 1;
  var nl=0;
  for(var i=0;i<text.length;i++){
    if(text.charCodeAt(i)===10) nl++;
  }
  return (text.charAt(text.length-1)==='\n') ? nl : nl+1;
}
function lineStartByNumber(text, ln){
  ln = ln|0;
  if (ln<=1) return 0;
  var cur=1, i=0, L=text.length;
  while(i<L && cur<ln){
    var j=text.indexOf('\n', i);
    if(j===-1) return L;
    i=j+1;
    // 末尾改行直後は空行として数えない（ln が行数上限を超えたら末尾へ）
    cur++;
  }
  return i;
}
function lineFirstNonBlankByNumber(text, ln){
  var s=lineStartByNumber(text, ln);
  var e=lineEndIndex(text,s);
  while(s<e && isSpace(text[s])) s++;
  return s;
}

// 行番号ライン範囲（linewise）削除ヘルパ : startLine, endLine を丸ごと削除
function deleteLineRange(editor, text, startLine, endLine){
  startLine = startLine|0; endLine = endLine|0;
  if (startLine < 1) startLine = 1;
  if (endLine < 1) endLine = 1;
  var fromLine = Math.min(startLine, endLine);
  var toLine   = Math.max(startLine, endLine);
  // 行開始位置
  var startIdx = lineStartByNumber(text, fromLine);
  var endLineStart = lineStartByNumber(text, toLine);
  var endIdx = lineEndIndex(text, endLineStart);
  // 末尾に改行があるなら含める（最終行でなければ +1）
  if (endIdx < text.length) endIdx = endIdx + 1;
  deleteRange(editor, startIdx, endIdx, { linewise: true });
}

// ==== 日本語対応の語移動ヘルパ ====
// サロゲートペア対応コードポイント処理
function _cpAt(str,i){ var hi=str.charCodeAt(i); if(hi>=0xD800&&hi<=0xDBFF&&i+1<str.length){ var lo=str.charCodeAt(i+1); if(lo>=0xDC00&&lo<=0xDFFF){ return (hi-0xD800)*0x400+(lo-0xDC00)+0x10000; } } return hi; }
function _nextIndex(str,i){ if(i>=str.length) return str.length; var hi=str.charCodeAt(i); if(hi>=0xD800&&hi<=0xDBFF&&i+1<str.length){ var lo=str.charCodeAt(i+1); if(lo>=0xDC00&&lo<=0xDFFF) return i+2; } return i+1; }
function _prevIndex(str,i){ if(i<=0) return 0; var lo=str.charCodeAt(i-1); if(lo>=0xDC00&&lo<=0xDFFF&&i-2>=0){ var hi=str.charCodeAt(i-2); if(hi>=0xD800&&hi<=0xDBFF) return i-2; } return i-1; }

// 語クラス判定
var _WT_SPACE=0,_WT_NL=1,_WT_ALNUM=2,_WT_KANA=3,_WT_HAN=4,_WT_SYMBOL=5;
function _isSpaceCp(cp){ return cp===0x20||cp===0x09||cp===0x3000; }
function _isNewlineCp(cp){ return cp===0x0A||cp===0x0D; }
function _isAsciiWordCp(cp){ return (cp>=0x30&&cp<=0x39)||(cp>=0x41&&cp<=0x5A)||(cp>=0x61&&cp<=0x7A)||cp===0x5F; }
function _isFullwidthAlnumCp(cp){ return (cp>=0xFF10&&cp<=0xFF19)||(cp>=0xFF21&&cp<=0xFF3A)||(cp>=0xFF41&&cp<=0xFF5A)||cp===0xFF3F; }
function _isKanaCp(cp){ return (cp>=0x3040&&cp<=0x309F)||(cp>=0x30A0&&cp<=0x30FF)||(cp>=0xFF66&&cp<=0xFF9D)||cp===0x30FC||cp===0x30FB; }
function _isHanCp(cp){ return (cp>=0x4E00&&cp<=0x9FFF)||(cp>=0x3400&&cp<=0x4DBF)||(cp>=0x20000&&cp<=0x2FA1F); }
function _wordTypeAt(str,i){
  if(i<0||i>=str.length) return _WT_SPACE;
  var cp=_cpAt(str,i);
  if(_isNewlineCp(cp)) return _WT_NL;
  if(_isSpaceCp(cp)) return _WT_SPACE;
  if(_isAsciiWordCp(cp)||_isFullwidthAlnumCp(cp)) return _WT_ALNUM;
  if(_isKanaCp(cp)) return _WT_KANA;
  if(_isHanCp(cp)) return _WT_HAN;
  return _WT_SYMBOL;
}

// b: 前の語頭へ（空白・改行を飛ばし、直前の語ブロックの先頭へ）
function wordLeftPos(text,pos){
  var i=pos;
  // 左側の空白/改行を飛ばす
  while(i>0){
    var pi=_prevIndex(text,i);
    var t=_wordTypeAt(text,pi);
    if(t!==_WT_SPACE && t!==_WT_NL) break;
    i=pi;
  }
  if(i<=0) return 0;
  // 直前位置の語タイプ
  var j=_prevIndex(text,i);
  var curT=_wordTypeAt(text,j);
  // その語ブロックの先頭へ
  while(j>0){
    var pj=_prevIndex(text,j);
    if(_wordTypeAt(text,pj)!==curT) break;
    j=pj;
  }
  return j;
}

// w: 次の語頭へ（現語ブロックの末尾→後続の空白/改行を飛ばして次の語頭）
function wordRightPos(text,pos){
  var n=text.length, i=pos;
  if(i>=n) return n;
  // 空白/改行の上ならまず飛ばす
  while(i<n){
    var t=_wordTypeAt(text,i);
    if(t!==_WT_SPACE && t!==_WT_NL) break;
    i=_nextIndex(text,i);
  }
  if(i>=n) return n;
  // 現在の語タイプの連続を抜ける
  var curT=_wordTypeAt(text,i);
  while(i<n && _wordTypeAt(text,i)===curT){
    i=_nextIndex(text,i);
  }
  // 次の語頭まで空白/改行を飛ばす
  while(i<n){
    var t2=_wordTypeAt(text,i);
    if(t2!==_WT_SPACE && t2!==_WT_NL) break;
    i=_nextIndex(text,i);
  }
  return i;
}
function posUp(text,pos,lines){
  lines=lines||1;
  var start=lineStartIndex(text,pos), col=pos-start, target=pos;
  for(var n=0;n<lines;n++){
    var prevEnd=start-1;
    if(prevEnd<0) break;
    var prevStart=lineStartIndex(text,prevEnd);
    var prevLen=prevEnd-prevStart;
    // VISUALモード時はanchorPosの列を維持できる範囲で移動
    if(mode===MODE_VISUAL && visualCol!==null){
      target=prevStart+Math.min(visualCol, prevLen);
    }else{
      target=prevStart+Math.min(col,prevLen);
    }
    start=prevStart;
  }
  return target;
}

function posDown(text,pos,lines){
  lines=lines||1;
  var start=lineStartIndex(text,pos), col=pos-start, target=pos;
  var nextStart=lineEndIndex(text,pos)+1;
  for(var n=0;n<lines;n++){
    if(nextStart<=0||nextStart>text.length) break;
    var nextEnd=lineEndIndex(text,nextStart);
    var nextLen=nextEnd-nextStart;
    // VISUALモード時はanchorPosの列を維持できる範囲で移動
    if(mode===MODE_VISUAL && visualCol!==null){
      target=nextStart+Math.min(visualCol, nextLen);
    }else{
      target=nextStart+Math.min(col,nextLen);
    }
    var afterNext=nextEnd+1;
    if(afterNext<=text.length) nextStart=afterNext; else break;
  }
  return target;
}
// 段落（空行区切り）
function isLineBlank(text, lineStart){ var end=lineEndIndex(text,lineStart); var s=text.slice(lineStart,end); return s.replace(/[ \t\u3000]/g,'').length===0; }
function paragraphPrev(text,pos){ var curStart=lineStartIndex(text,pos); var j=curStart-1;
  while(j>=0){ var ls=lineStartIndex(text,j); if(isLineBlank(text,ls)){ var nextStart=lineEndIndex(text,ls)+1; return firstNonBlankPos(text, Math.min(nextStart,text.length)); } j=ls-1; }
  return firstNonBlankPos(text,0); }
function paragraphNext(text,pos){ var i=lineEndIndex(text,pos)+1;
  while(i<=text.length){ if(i>=text.length){ var lastStart=text.lastIndexOf('\n')+1; return firstNonBlankPos(text,lastStart); }
    var ls=i, le=lineEndIndex(text,ls); if(isLineBlank(text,ls)){ var k=le+1; while(k<=text.length && isLineBlank(text,k)) k=lineEndIndex(text,k)+1;
      return firstNonBlankPos(text, Math.min(k,text.length)); } i=le+1; } return pos; }

// --- 最終行終端判定（Ctrl+N / w で末行から“下”に抜けるのを防止）---
if (typeof isAtLastLineCaret !== 'function') {
  function isAtLastLineCaret(text, pos){
    if (!text) return true;
    var tl = totalLines(text);
    var lc = getLineCol(text, pos).line;
    if (lc !== tl) return false;
    if (text.length === 0) return true;
    if (text.charAt(text.length-1) === '\n') {
      // 末尾改行あり: 改行文字（length-1）位置が最終行終端
      return pos >= text.length - 1;
    }
    // 末尾改行なし: EOF が終端
    return pos >= text.length;
  }
}

// （追加）isAtLastLineCaret の直後など、既存ユーティリティ付近に挿入
// --- 最終行判定（行番号のみで判定：末尾の位置に依らず最終行なら true）---
if (typeof isOnLastLine !== 'function') {
  function isOnLastLine(text, pos){
    if (!text) return true;
    return getLineCol(text, pos).line === totalLines(text);
  }
}

// ====== モード管理 ======
var MODE_NORMAL='NORMAL', MODE_INSERT='INSERT', MODE_VISUAL='VISUAL';
var mode = MODE_NORMAL, anchorPos=null, visualCol = null, opPending = null, lastMotionDir = null; // ←追加: 直前の移動方向を記憶
// 直前コマンドの種別と、直前削除が行単位だったかを記録（dd連打で追記するため）
var lastCmd = null, lastDeleteLinewise = false;
// 数値接頭辞バッファと演算子の繰り返し数（N d {motion} の N）
var countBuffer = '';
var opRepeat = 1;
// 追加: 'g' プレフィックス待機フラグ（gg 判定用）
var gPending = false;
// 追加: VISUAL選択の“アクティブ端”（直近モーションで動いた側）を保持
var visActiveEnd = null;

function setMode(newMode, editor){
  var prev = mode;
  mode=newMode;
  document.getElementById('mode').innerText='['+mode+']';

  if(mode===MODE_INSERT){
    if(!insertSessionActive){
      pushUndo('insert-begin');
      insertSessionActive = true;
    }
    anchorPos=null; visualCol=null; opPending=null; lastMotionDir=null; visActiveEnd=null;
    countBuffer=''; opRepeat=1;
  }else if(mode===MODE_VISUAL){
    anchorPos=getCaret(editor);
    visualCol = getLineCol(editor.value, anchorPos).col - 1;
    setSelection(editor,anchorPos,anchorPos);
    lastMotionDir=null; visActiveEnd=null;
    countBuffer=''; opRepeat=1;
    if(prev===MODE_INSERT) insertSessionActive=false;
  }else{ // NORMAL
    anchorPos=null; visualCol=null; opPending=null; lastMotionDir=null; visActiveEnd=null;
    countBuffer=''; opRepeat=1;
    if(editor && editor.selectionStart!==editor.selectionEnd){
      setCaret(editor, editor.selectionEnd);
    }
    if(prev===MODE_INSERT) insertSessionActive=false;
  }
  lastCmd='other';
  updateStatus(editor); ensureScrolloff(editor);
}

function posUp(text,pos,lines){
  lines=lines||1;
  var start=lineStartIndex(text,pos), col=pos-start, target=pos;
  for(var n=0;n<lines;n++){
    var prevEnd=start-1;
    if(prevEnd<0) break;
    var prevStart=lineStartIndex(text,prevEnd);
    var prevLen=prevEnd-prevStart;
    // VISUALモード時はanchorPosの列を維持できる範囲で移動
    if(mode===MODE_VISUAL && visualCol!==null){
      target=prevStart+Math.min(visualCol, prevLen);
    }else{
      target=prevStart+Math.min(col,prevLen);
    }
    start=prevStart;
  }
  return target;
}

function posDown(text,pos,lines){
  lines=lines||1;
  var start=lineStartIndex(text,pos), col=pos-start, target=pos;
  var nextStart=lineEndIndex(text,pos)+1;
  for(var n=0;n<lines;n++){
    if(nextStart<=0||nextStart>text.length) break;
    var nextEnd=lineEndIndex(text,nextStart);
    var nextLen=nextEnd-nextStart;
    // VISUALモード時はanchorPosの列を維持できる範囲で移動
    if(mode===MODE_VISUAL && visualCol!==null){
      target=nextStart+Math.min(visualCol, nextLen);
    }else{
      target=nextStart+Math.min(col,nextLen);
    }
    var afterNext=nextEnd+1;
    if(afterNext<=text.length) nextStart=afterNext; else break;
  }
  return target;
}

// 文字範囲の削除（x / d{motion} 用）
function deleteRange(editor, a, b, opts){
  pushUndo('delete');
  var v = editor.value;
  var s = Math.max(0, Math.min(a, b));
  var e = Math.max(0, Math.max(a, b));
  if (s === e) return;
  var deleted = v.slice(s, e);
  var isLinewise = !!(opts && opts.linewise);
  // 行単位削除はレジスタ内で必ず改行終端に正規化（最終行でも複数行貼り付け可）
  if (isLinewise && !/\n$/.test(deleted)) deleted += '\n';
  // 直前も行単位の削除なら、無名レジスタに追記（dd 連打で複数行保持）
  var append = (lastCmd === 'delete' && lastDeleteLinewise && isLinewise);
  var regText = append ? (REG.text + deleted) : deleted;
  setRegister(regText, isLinewise);
  editor.value = v.slice(0, s) + v.slice(e);
  setCaret(editor, s);
  modifiedCount++; updateModifiedFlag();
  updateStatus(editor);
  ensureScrolloff(editor);
  updateGutter();
  // 今回のコマンドを記録
  lastCmd = 'delete';
  lastDeleteLinewise = isLinewise;
}

// 無名レジスタとクリップボード
var REG = { text: '', linewise: false };
function setClipboardText(t){
  try{ if(window.clipboardData && typeof window.clipboardData.setData==='function'){ window.clipboardData.setData('Text', t); return true; } }catch(_){}
  return false;
}
function getClipboardText(){
  try{ if(window.clipboardData && typeof window.clipboardData.getData==='function'){ var t = window.clipboardData.getData('Text'); return (typeof t==='string')?t:null; } }catch(_){}
  return null;
}
function setRegister(text, linewise){
  REG.text = text || '';
  REG.linewise = !!linewise;
  if (OPT.clipboard === 'os') setClipboardText(REG.text);
}
function getRegister(){
  if (OPT.clipboard === 'os'){
    var t = getClipboardText();
    if (typeof t === 'string') return { text: t, linewise: /\n$/.test(t) };
  }
  return { text: REG.text, linewise: REG.linewise };
}

// 貼り付け実装
function pasteInsert(editor, insPos, t){
  pushUndo('paste');
  var v = editor.value;
  editor.value = v.slice(0, insPos) + t + v.slice(insPos);
  setCaret(editor, insPos + t.length);
  modifiedCount++; updateModifiedFlag();
  updateStatus(editor); ensureScrolloff(editor); updateGutter();
  // 貼り付けでチェーンを切る
  lastCmd = 'other';
}
function pasteAfter(editor){
  var reg = getRegister();
  var v = editor.value;
  var s = editor.selectionStart, en = editor.selectionEnd;
  var pos = getCaret(editor);

  // VISUAL中は選択置換
  if (mode === MODE_VISUAL && s !== en){
    editor.value = v.slice(0, s) + v.slice(en);
    pos = s; v = editor.value;
  }
  if (reg.linewise){
    var le = lineEndIndex(v, pos);
    var ins = (le < v.length) ? le + 1 : v.length; // 次行頭 or EOF
    pasteInsert(editor, ins, reg.text);
  }else{
    var ins = Math.min(v.length, pos + (mode===MODE_VISUAL ? 0 : 1)); // NORMALは“後”、VISUAL置換後はその位置
    pasteInsert(editor, ins, reg.text);
  }
}
function pasteBefore(editor){
  var reg = getRegister();
  var v = editor.value;
  var s = editor.selectionStart, en = editor.selectionEnd;
  var pos = getCaret(editor);

  // VISUAL中は選択置換
  if (mode === MODE_VISUAL && s !== en){
    editor.value = v.slice(0, s) + v.slice(en);
    pos = s; v = editor.value;
  }
  if (reg.linewise){
    var ls = lineStartIndex(v, pos);
    pasteInsert(editor, ls, reg.text);
  }else{
    var ins = pos; // “前”
    pasteInsert(editor, ins, reg.text);
  }
}

// ====== ステータス・メッセージ・ヘルプ ======
function updateStatus(editor){
  var start=editor.selectionStart!=null?editor.selectionStart:getCaret(editor);
  var end=editor.selectionEnd!=null?editor.selectionEnd:start;
  var caret=end; var lc=getLineCol(editor.value,caret); var sel=Math.abs(end-start);
  var info='Ln '+lc.line+', Col '+lc.col; if(sel>0) info+=' (Sel '+sel+')';
  document.getElementById('pos').innerText=info;
  document.getElementById('hint').innerText =
    '移動: h j k l / w b / ^ 0 $ / { } | 挿入: i | VISUAL: v | 取消: Esc | Emacs: Ctrl+P/N/F/B | ヘルプ: F1/:help';
  var filename = window._currentFile || '[No Name]';
  var modmark = (modifiedCount > 0) ? '[+]' : '';
  document.getElementById('filename').innerText = filename;
  document.getElementById('modmark').innerText = modmark;
  document.getElementById('mode').innerText = '['+mode+']';
}
function showMsg(text, hold){
  var cmdmsg = document.getElementById('cmdmsg');
  cmdmsg.innerText = text;
  cmdmsg.style.display = 'block';
  showMsg._hold = !!hold;
  setTimeout(function(){ document.getElementById('editor').focus(); }, 0);
  if (!hold) {
    clearTimeout(showMsg._t);
    showMsg._t = setTimeout(function(){
      cmdmsg.style.display = 'none';
      showMsg._hold = false;
    }, 1200);
  }
}
function hideMsg(){
  var cmdmsg = document.getElementById('cmdmsg');
  cmdmsg.innerText = '';
  cmdmsg.style.display = 'none';
  showMsg._hold = false;
}

function showHelp(){ document.getElementById('help').style.display='block'; }
function hideHelp(){
  document.getElementById('help').style.display='none';
  hideMsg();
}
function toggleHelp(){ var h=document.getElementById('help'); h.style.display = (h.style.display==='block'?'none':'block'); }

// ====== ガター ======
function updateGutter() {
  var gutter = document.getElementById('gutter');
  var editor = document.getElementById('editor');
  if (!OPT.number) {
    gutter.style.display='none';
    editor.style.paddingLeft='10px';
    return;
  }
  gutter.style.display='block';
  editor.style.paddingLeft='82px';
  var text = editor.value;
  var total = totalLines(text);
  var lh = getLineHeightPx(editor);
  // ステータスバー高さ差し引き
  var STATUSBAR_H = 28;
  var effHeight = editor.clientHeight - STATUSBAR_H;
  if (effHeight < lh) effHeight = lh;
  var startLine = Math.floor(editor.scrollTop / lh);
  var visible = Math.ceil(effHeight / lh) + 1;
  var endLine = Math.min(total, startLine + visible);
  var html = [];
  for (var ln = startLine + 1; ln <= endLine; ln++) {
    html.push('<div class="ln">' + ln + '</div>');
  }
  gutter.innerHTML = html.join('');
  var offset = -(editor.scrollTop % lh);
  gutter.style.transform = 'translateY(' + offset + 'px)';
}


// ====== scrolloff（表示端からの余白スクロール） ======
function ensureScrolloff(editor){
  try{
    var lh = getLineHeightPx(editor);
    if(!lh || !isFinite(lh) || lh<=0) return;

    var text = editor.value;
    var total = totalLines(text);
    var pos  = (typeof editor.selectionEnd==='number')?editor.selectionEnd:getCaret(editor);
    var cursorLine = getLineCol(text,pos).line;

    var STATUSBAR_H = 28;          // 下部バー高さ
    var clientH = editor.clientHeight;
    var visibleH = clientH - STATUSBAR_H;
    if (visibleH < lh) visibleH = lh;

    var curTop = editor.scrollTop;
    var realMax = editor.scrollHeight - clientH;
    if (realMax < 0) realMax = 0;

    var cursorTop    = (cursorLine - 1) * lh;
    var cursorBottom = cursorTop + lh;

    var desiredTop = curTop;
    var scrolloffLines = 3;
    var upMarginPx   = scrolloffLines * lh;
    var downMarginPx = scrolloffLines * lh;

    var isLastLine = (cursorLine === total);

    if (isLastLine){
      // 行が完全に見えるように: 行底を (visibleH - (任意の余白)) 内に入れる
      // 下端ギリ配置ではなく 1 行分余裕を持たせる: 行底が (cursorBottom) → desiredTop = cursorBottom - (visibleH - lh)
      desiredTop = cursorBottom - (visibleH - lh);
      // これで行上端 = desiredTop + 0 となり必ず可視
      if (desiredTop < 0) desiredTop = 0;
      if (desiredTop > realMax) desiredTop = realMax;

      // 万一 行上端がさらに上すぎて（丸ごと見えているのに余白過多）なら調整
      if (cursorTop < desiredTop){
        desiredTop = cursorTop;
        if (desiredTop > realMax) desiredTop = realMax;
        if (desiredTop < 0) desiredTop = 0;
      }

      // 行底が隠れている場合の再補正
      var viewBottom = desiredTop + visibleH;
      if (cursorBottom > viewBottom){
        desiredTop = cursorBottom - (visibleH - 0); // もう一度
        if (desiredTop < 0) desiredTop = 0;
        if (desiredTop > realMax) desiredTop = realMax;
      }
    } else {
      // 通常行: scrolloff
      if (cursorTop - upMarginPx < curTop){
        desiredTop = cursorTop - upMarginPx;
      } else {
        var viewBottom = curTop + visibleH;
        if (cursorBottom + downMarginPx > viewBottom){
          desiredTop = cursorBottom + downMarginPx - visibleH;
        }
      }
      if (desiredTop < 0) desiredTop = 0;
      if (desiredTop > realMax) desiredTop = realMax;
    }

    if (Math.abs(desiredTop - curTop) >= 0.5){
      editor.scrollTop = desiredTop;
    }
  }catch(_){}
}

// ====== コマンドバー ======
function openCmdBar(){
  hideMsg();
  var inp=document.getElementById('cmdline');
  document.getElementById('cmdprefix').style.display = 'inline-block';
  inp.style.display = 'inline-block';
  inp.value='';
  inp.focus();
}
function closeCmdBar(){
  var inp=document.getElementById('cmdline');
  inp.blur();
  inp.style.display = 'none';
  document.getElementById('cmdprefix').style.display = 'none';
  setMode(MODE_NORMAL, document.getElementById('editor'));
  hideMsg();
  document.getElementById('editor').focus(); 
}
function runCommand(cmd){
  var s=(cmd||'').trim();
  if(s===''){ closeCmdBar(); return; }

  if (/^u$/i.test(s)){
    closeCmdBar();
    doUndo();
    return;
  }

  // help
  if (/^(help|\?)$/i.test(s)) { closeCmdBar(); showHelp(); return; }

  // 数値のみ: 行番号へジャンプ（:99 など）
  if (/^\d+$/.test(s)) {
    var ln = parseInt(s,10);
    var ed = document.getElementById('editor');
    var t = ed.value;
    var pos = lineFirstNonBlankByNumber(t, ln);
    setCaret(ed, pos);
    closeCmdBar();
    return;
  }

  if (/^debugscroll$/i.test(s)){
    closeCmdBar();
    var ed = document.getElementById('editor');
    var lh = getLineHeightPx(ed);
    var ch = ed.clientHeight;
    var sh = ed.scrollHeight;
    var STATUSBAR_H = 28;
    var effH = ch - STATUSBAR_H;
    var tl = totalLines(ed.value);
    var pos = getCaret(ed);
    var line = getLineCol(ed.value,pos).line;
    var maxST = sh - ch; if (maxST < 0) maxST = 0;
    showMsg('lh='+lh+' ch='+ch+' sh='+sh+' effH='+effH+' scrollTop='+ed.scrollTop+' maxST='+maxST+' line='+line+'/'+tl, true);
    return;
  }

  // set number / nonumber / clipboard
  var m = s.match(/^set\s+(.+)$/i);
  if (m) {
    var arg = m[1].trim().toLowerCase();
    if (arg==='number' || arg==='nu') { OPT.number=true; updateGutter(); closeCmdBar(); return; }
    if (arg==='nonumber' || arg==='nonu') { OPT.number=false; updateGutter(); closeCmdBar(); return; }
    if (arg==='clipboard=os') { OPT.clipboard='os'; showMsg('clipboard=os', 1200); closeCmdBar(); return; }
    if (arg==='clipboard=internal') { OPT.clipboard='internal'; showMsg('clipboard=internal', 1200); closeCmdBar(); return; }
    showMsg('unknown option: ' + arg, 1400); closeCmdBar(); return;
  }

  // :e / :edit (UTF-8対応)
  if (/^e(dit)?\\s+.+/i.test(s)) {
    try {
      var path = s.replace(/^e(dit)?\\s+/i, "").trim();
      var fso = new ActiveXObject("Scripting.FileSystemObject");
      if (fso.FileExists(path)) {
        var stream = new ActiveXObject("ADODB.Stream");
        stream.Type = 2; // text
        stream.Charset = "UTF-8";
        stream.Open();
        stream.LoadFromFile(path);
        var content = stream.ReadText();
        stream.Close();
        editor.value = content;
        showMsg("Loaded: " + path, 1500);
      } else {
        showMsg("File not found: " + path, 2000);
      }
    } catch(e) {
      showMsg("Error loading file", 2000);
    }
    closeCmdBar();
    return;
  }

  // :e / :edit (UTF-8対応)
  if (/^e(dit)?\s+.+/i.test(s)) {
    try {
      var path = s.replace(/^e(dit)?\s+/i, "").trim();
      var fso = new ActiveXObject("Scripting.FileSystemObject");
      if (fso.FileExists(path)) {
        var stream = new ActiveXObject("ADODB.Stream");
        stream.Type = 2; // text
        stream.Charset = "UTF-8";
        stream.Open();
        stream.LoadFromFile(path);
        var content = stream.ReadText();
        stream.Close();
        editor.value = content;
        window._currentFile = path; // ファイル名を記憶
        showMsg("Loaded: " + path, 1500);
        editor.focus(); setCaret(editor, 0);
        setBaseline(content); // ファイル読込時は未編集状態に
      } else {
        showMsg("File not found: " + path, 2000);
      }
    } catch(e) {
      showMsg("Error loading file", 2000);
    }
    closeCmdBar();
    return;
  }

  // （:w / :q などは v0.4 で実装）
  // open file

  // quit
  // 強制終了
  if (/^q!$/i.test(s)) {
    closeCmdBar();
    window.close();
    return;
  }
  // quit（警告あり）
  if (/^q$/i.test(s)) {
    if (modifiedCount > 0) {
      showMsg('編集内容が保存されていません', true);
      return;
    }
    closeCmdBar();
    window.close();
    return;
  }

  showMsg('未実装: ' + s, 1200);
  closeCmdBar();
}

// ====== 入力処理 ======
function composing(e){ return e && (e.isComposing || e.keyCode===229); }
function handleMove(editor, target, selecting){
  var text = editor.value;
  target = Math.max(0, Math.min(target, text.length));
  if(mode===MODE_VISUAL||selecting){
    if(anchorPos==null) anchorPos=getCaret(editor);
    // VISUALモード時はexclusive selection
    if (mode === MODE_VISUAL) {
      setSelection(editor, anchorPos, target);
      // どちら側が“動いた端”かを記録（次のモーション基準に使う）
      visActiveEnd = (target < anchorPos) ? 'start' : 'end';
    } else {
      setSelection(editor, anchorPos, target);
    }
  } else {
    setCaret(editor, target);
  }
  // 移動系コマンドが実行されたので、ddの追記チェーンはここで切る
  lastCmd = 'move';
  updateStatus(editor); ensureScrolloff(editor);
}
function tryEmacsCtrl(editor,e){
  if(!e.ctrlKey||e.altKey) return false;
  var k = (typeof e.key==='string'
           ? e.key.toLowerCase()
           : String.fromCharCode(e.keyCode).toLowerCase());
  var text = editor.value;
  var target = getCaret(editor);
  var handled = true;

  if (k === 'p'){ // Ctrl+P = 上
    var p = getActivePosForDir(editor,'up');
    target = posUp(text,p,1);
    lastMotionDir='up';
  }
  // （置換）tryEmacsCtrl 内の  else if (k === 'n'){ ... } ブロック
  else if (k === 'n'){ // Ctrl+N = 下
    var p = getActivePosForDir(editor,'down');
    // 現在が最終行なら不動
    if (isOnLastLine(text, p)){
      e.preventDefault(); e.stopPropagation();
      return true;
    }
    var np = posDown(text, p, 1);
    // 進めない（物理的に同じ位置）
    if (np === p){
      e.preventDefault(); e.stopPropagation();
      return true;
    }
    // 最終行への“侵入”は許可（ここが前回との違い）
    target = np;
    lastMotionDir='down';
  }
  else if (k === 'f'){ // Ctrl+F = 右
    var p = getActivePosForDir(editor,'right');
    target = Math.min(text.length, p+1);
    lastMotionDir='right';
  }
  else if (k === 'b'){ // Ctrl+B = 左
    var p = getActivePosForDir(editor,'left');
    target = Math.max(0, p-1);
    lastMotionDir='left';
  }
  else {
    handled = false;
  }

  if (handled){
    e.preventDefault(); e.stopPropagation();
    handleMove(editor, target, mode===MODE_VISUAL);
    return true;
  }
  return false;
}

// ====== INIT ======
(function init(){
  var editor=document.getElementById('editor');
  editor.value =
    '# Vi-like Text Editor "tedit" v0.3.3 (paste+help)\n' +
    '行番号: :set number / :set nonumber（起動時は number=on）。wrap=off 前提。\n' +
    '移動: h j k l / w b / ^（先頭非空白）/ 0 / $ / 段落 { }\n' +
    'モード: i → INSERT, v → VISUAL, Esc → NORMAL\n' +
    'Emacs代替: Ctrl+P/N/F/B（全モード）\n' +
    'ペースト: INSERTでCtrl+V/Shift+Ins/右クリック可（改行はLFに正規化）。NORMALでは不可。\n' +
    'ヘルプ: F1 または :help\n';

  editor.focus();
  setMode(MODE_NORMAL,editor);
  setCaret(editor, 0);
  pushUndo('initial');
  setBaseline(editor.value);
  updateStatus(editor); ensureScrolloff(editor); updateGutter();
  // 行番号ガターの初期表示
  updateGutter();
  // ステータスバー初期表示
  document.getElementById('cmdline').style.display = 'none';
  document.getElementById('cmdprefix').style.display = 'none';

  // --- キー処理（エディタ） ---
  editor.addEventListener('keydown', function(e){
    if(document.getElementById('cmdbar').style.display==='flex') return;
    if(tryEmacsCtrl(editor,e)) return;

    var key = (typeof e.key==='string')?e.key:String.fromCharCode(e.keyCode);
    var lower = key.toLowerCase();
    var text=editor.value, pos=getCaret(editor);

    // --- 修飾キー単独押下は状態を壊さず無視（Shift が countBuffer/opPending を消していた原因） ---
    // IE/HTA では Shift 押下だけでも keydown が飛ぶためここで即リターン
    if (
      key === 'Shift' || key === 'Control' || key === 'Alt' || key === 'Meta' ||
      e.keyCode === 16 || e.keyCode === 17 || e.keyCode === 18 || e.keyCode === 91
    ) {
      return;
    }

    if(mode===MODE_INSERT){
      if(composing(e)) return;
      if(key==='Escape'||e.keyCode===27){ e.preventDefault(); e.stopPropagation(); setMode(MODE_NORMAL,editor); return; }
      return; // 通常入力は素通し
    }

    // NORMAL / VISUAL
    if(composing(e)){ e.preventDefault(); }
    e.preventDefault(); e.stopPropagation();

    // モード切替・ヘルプ・Ex
    if(lower==='i'){ setMode(MODE_INSERT,editor); return; }
    if(lower==='v'){ setMode(mode===MODE_VISUAL?MODE_NORMAL:MODE_VISUAL,editor); return; }
    if(key==='Escape'||e.keyCode===27){ setMode(MODE_NORMAL,editor); return; }
    if(key===':'){ openCmdBar(); return; }

    // --- 数値接頭辞 ---
    if (lower>='0' && lower<='9'){
      if (lower==='0' && countBuffer===''){
        // 単独 0 は行頭コマンド
      } else {
        countBuffer += lower;
        return;
      }
    }

    function takeCount(def){
      var n = parseInt(countBuffer||'',10);
      countBuffer='';
      if(!isFinite(n) || n<=0) return (def==null?1:def);
      return n;
    }

    // --- G / NG 早期処理（大文字 G 判定を強化）---
    var isUpperG = (key === 'G') || (e.shiftKey && (key === 'g' || key === 'G')) || (e.shiftKey && e.keyCode === 71);
    if (isUpperG){
      var tl  = totalLines(text);
      var curLine = getLineCol(text, pos).line;
      var raw = countBuffer; countBuffer='';
      var n = parseInt(raw||'',10);
      var line = (isFinite(n)&&n>0) ? Math.min(tl,n) : tl;

      if (opPending === 'd'){
        deleteLineRange(editor, text, curLine, line);
        opPending=null; opRepeat=1; gPending=false;
        return;
      }

      // 要望: 最終行で末尾改行なし→行末(=EOF)、末尾改行あり→改行文字位置
      var startIdx = lineStartByNumber(text, line);
      var targetPos;
      if (line === tl){
        // 末尾が改行なら改行文字位置、無ければ EOF (=その行末)
        targetPos = (text.charAt(text.length-1)==='\n') ? text.length-1 : text.length;
        // 安全: startIdx を越えているならそのまま（textarea では text.length も妥当）
        if (targetPos < startIdx) targetPos = startIdx;
      }else{
        // 中間行は行頭（好みにより firstNonBlank へ変更可）
        targetPos = startIdx;
      }

      lastMotionDir = (line >= curLine) ? 'down' : 'up';
      handleMove(editor, targetPos, mode===MODE_VISUAL);
      // 明示再調整
      ensureScrolloff(editor);
      gPending = false;
      return;
    }

    // 'g' 以外入力で gPending 解除（上の G 早期処理後に判定）
    if (lower !== 'g') gPending = false;

    // 移動（NORMAL/ VISUAL）
    var target=pos, selecting=(mode===MODE_VISUAL);
    switch(lower){
      // --- g / gg / Ngg 専用（G は早期処理へ分離）---
      case 'g': {
        // gg / Ngg
         if (gPending){
           var raw2 = countBuffer; countBuffer='';
           var n2 = parseInt(raw2||'',10);
           var line2 = (isFinite(n2)&&n2>0) ? n2 : 1;
           var curLineObj2 = getLineCol(text, pos);
           if (opPending === 'd'){
             // dgg / dNgg 行単位削除
             deleteLineRange(editor, text, curLineObj2.line, line2);
             opPending=null; opRepeat=1; gPending=false;
             return;
           }
           var tpos2 = lineFirstNonBlankByNumber(text, line2);
           lastMotionDir = (line2 < curLineObj2.line) ? 'up' : 'down';
           target = tpos2;
           gPending=false;
           break;
         } else {
           // 1文字目の 'g' 待機（カウントは保持したまま）
           gPending=true;
           return;
         }
      }

      case 'u': { // undo
        if (mode===MODE_NORMAL){
          doUndo();
          countBuffer=''; opPending=null; opRepeat=1;
          return;
        }
        break;
      }

      // --- 削除（単体） ---
      case 'x': {
        if (mode!==MODE_INSERT){
          var n = takeCount(1);
          if (pos < text.length) deleteRange(editor, pos, Math.min(text.length, pos+n));
          opRepeat = 1; // 単発コマンドで演算子カウントはリセット
          return;
        }
        break;
      }

      // --- 貼り付け ---
      case 'p':
        if (mode!==MODE_INSERT){ pasteAfter(editor); countBuffer=''; opRepeat=1; return; }
        break;
      case 'P':
        if (mode!==MODE_INSERT){ pasteBefore(editor); countBuffer=''; opRepeat=1; return; }
        break;

      // --- 演算子 d （次のモーションで削除）---
      case 'd': {
        if (mode!==MODE_INSERT){
          if (opPending === 'd') {
            var lines = opRepeat * takeCount(1);
            if (lines < 1) lines = 1;
            var ls = lineStartIndex(text, pos);
            var tpos = pos, lastEnd = lineEndIndex(text, tpos);
            for (var i=1;i<lines;i++){
              if (lastEnd >= text.length) break;
              var nextStart = lastEnd + 1;
              lastEnd = lineEndIndex(text, nextStart);
            }
            var e  = (lastEnd < text.length) ? lastEnd + 1 : lastEnd;
            deleteRange(editor, ls, e, { linewise: true });
            opPending = null;
            opRepeat = 1;
            return;
          }
          opPending = 'd';
          opRepeat = takeCount(1);
          return;
        }
        break;
      }

      case 'h': {
        var p = getActivePosForDir(editor,'left');
        var n = takeCount(1);
        if (opPending === 'd'){
          if (p > 0) deleteRange(editor, Math.max(0, p-n), p); // d{n}h
          opPending = null;
          opRepeat = 1;
          return;
        }
        target=Math.max(0,p-n); lastMotionDir='left'; break;
      }

      case 'l': {
        var p = getActivePosForDir(editor,'right');
        var n = takeCount(1);
        if (opPending === 'd'){
          if (p < text.length) deleteRange(editor, p, Math.min(text.length, p+n)); // d{n}l
          opPending = null;
          opRepeat = 1;
          return;
        }
        target=Math.min(text.length,p+n); lastMotionDir='right'; break;
      }

      case 'j': {
        var n = takeCount(1);

        // j の基準位置（VISUAL 対応）
        var p = getActivePosForDir(editor,'down');
        var tl = totalLines(text);
        var curLine = getLineCol(text, p).line;

        // 既に最終行なら何もしない（末尾改行有無どちらでも不動）
        if (curLine === tl) {
          // 演算子待機中 (d など) の場合は取り消し
          if (opPending) { opPending = null; opRepeat = 1; }
          break;
        }

        // 下へ n 行（1 行ずつ進めて途中で最終行に到達したら停止）
        var newPos = p;
        for (var i = 0; i < n; i++) {
          var step = posDown(text, newPos, 1);
          if (step === newPos) break; // 進めない（安全策）
          newPos = step;
          if (getLineCol(text, newPos).line >= tl) break;
        }

        // 実質移動できなければ終了
        if (newPos === p) {
          if (opPending) { opPending = null; opRepeat = 1; }
          break;
        }

        // d{count}j のような演算子付き（未実装なら無視）
        if (opPending === 'd') {
          // 現在行頭～移動先行頭直前までを削除（簡易。必要なら行単位処理に拡張）
          var startLine = getLineCol(text, p).line;
            var endLine = getLineCol(text, newPos).line;
          deleteLineRange(editor, text, startLine, endLine);
          opPending = null; opRepeat = 1;
          break;
        }

        target = newPos;
        lastMotionDir = 'down';
        break;
      }

      case 'k': {
        var p = getActivePosForDir(editor,'up');
        var n = takeCount(1);
        target=posUp(text,p,n); lastMotionDir='up'; break;
      }

      case 'w': {
        var nMotion = takeCount(1);
        var tl = totalLines(text);
        var curLine = getLineCol(text, pos).line;

        // 既に最終行 → w は不動（末尾から下方向に抜けないため）
        if (curLine === tl){
          if (opPending) { opPending=null; opRepeat=1; }
          break;
        }

        var nTotal = (opPending==='d' ? opRepeat*nMotion : nMotion);
        var p0 = (opPending==='d' ? pos : getActivePosForDir(editor,'right'));
        var t = p0;

        for (var i=0;i<nTotal;i++){
          var next = wordRightPos(text, t);
          if (next === t) break;  // 進めない
          t = next;
          // （前回: 最終行へ入ったら戻す処理があった → 削除）
        }

        if (opPending === 'd'){
          if (t > pos) deleteRange(editor, pos, t);
          opPending=null; opRepeat=1;
          return;
        }

        if (t === pos || t === p0){
          break;
        }

        target = t;
        lastMotionDir='right';
        break;
      }

      case 'b': {
        var nMotion = takeCount(1);
        var nTotal = (opPending==='d'? opRepeat*nMotion : nMotion);
        var p0 = (opPending==='d'? pos : getActivePosForDir(editor,'left'));
        var t = p0;
        for (var i=0;i<nTotal;i++){ t = wordLeftPos(text, t); }
        if (opPending === 'd'){
          if (t < pos) deleteRange(editor, t, pos);
          opPending=null; opRepeat=1; return;
        }
        target=t; lastMotionDir='left'; break;
      }

      case '$': {
        // カウントありの $ は n 行下の行末へ（Vim互換: 2$ で次行の行末）
        var dirVis = (mode===MODE_VISUAL && editor.selectionStart!==editor.selectionEnd && (lastMotionDir==='left'||lastMotionDir==='up')) ? 'left' : 'right';
        var nMotion = takeCount(1);
        if (opPending === 'd'){
          var nTotal = Math.max(1, opRepeat * nMotion);
          var tpos = pos, tend = lineEndIndex(text, tpos);
          for (var i=1;i<nTotal;i++){
            if (tend >= text.length) break;
            var ns = tend + 1;
            tend = lineEndIndex(text, ns);
          }
          if (tend > pos) deleteRange(editor, pos, tend);
          opPending=null; opRepeat=1; return;
        }
        var pbase = getActivePosForDir(editor, dirVis);
        var tpos = pbase, tend = lineEndIndex(text, tpos);
        for (var i=1;i<nMotion;i++){
          if (tend >= text.length) break;
          var ns = tend + 1;
          tend = lineEndIndex(text, ns);
        }
        target = tend; lastMotionDir = dirVis; break;
      }

      case '0': {
        // VISUAL時は直前の移動方向に応じて“動いている端”の行頭へ
        (function(){
          var isVisual = (mode===MODE_VISUAL && editor.selectionStart!==editor.selectionEnd);
          var dir = (isVisual && (lastMotionDir==='right'||lastMotionDir==='down')) ? 'right' : 'left';
          var p = getActivePosForDir(editor, dir);
          target = lineStartIndex(text, p);
          lastMotionDir = dir;
          countBuffer=''; // 0 は行頭。数値は消費済み扱い。
        })();
        break;
      }
 
      case '^': {
        // VISUAL時は直前の移動方向に応じて“動いている端”の先頭非空白へ
        (function(){
          var isVisual = (mode===MODE_VISUAL && editor.selectionStart!==editor.selectionEnd);
          var dir = (isVisual && (lastMotionDir==='right'||lastMotionDir==='down')) ? 'right' : 'left';
          var p = getActivePosForDir(editor, dir);
          target = firstNonBlankPos(text, p);
          lastMotionDir = dir;
          countBuffer=''; // ^ は行頭非空白。数値は使わない。
        })();
        break;
      }

      case '{': {
        var p = getActivePosForDir(editor,'up');
        var n = takeCount(1);
        var t = p; for (var i=0;i<n;i++){ t = paragraphPrev(text, t); }
        target=t; lastMotionDir='up'; break;
      }

      case '}': {
        var p = getActivePosForDir(editor,'down');
        var n = takeCount(1);
        var t = p; for (var i=0;i<n;i++){ t = paragraphNext(text, t); }
        target=t; lastMotionDir='down'; break;
      }
      default:
        // NORMAL での OS ペースト・コンテキストメニュー抑止（paste イベントでも弾くが、ヒントを出す）
        if ((e.ctrlKey && !e.altKey && lower==='v') || (e.shiftKey && e.key==='Insert')) {
          showMsg('NORMALでは貼り付けできません（i で INSERT へ）', 1400);
        }
        // 無関係キーで d をキャンセル
        opPending = null; opRepeat=1; countBuffer='';
        gPending = false;
        return;
    }
    handleMove(editor,target,selecting);
  });

  // スクロール/入力/リサイズ
  editor.addEventListener('scroll', function(){ updateGutter(); });
  editor.addEventListener('input',  function(){
    updateStatus(editor); ensureScrolloff(editor); updateGutter();
    modifiedCount++; updateModifiedFlag();
  });
  editor.addEventListener('click',  function(){ updateStatus(editor); ensureScrolloff(editor); if(mode!==MODE_VISUAL) anchorPos=null; });
  window.addEventListener('resize', function(){ updateGutter(); });
  // 行番号表示のためのイベント
  editor.addEventListener('keyup', function(){ updateGutter(); });

  // ペースト：INSERT 以外は拒否。INSERT では LF 正規化。
  editor.addEventListener('paste', function(e){
    // NORMAL/VISUAL では完全拒否
    if (mode !== MODE_INSERT) {
      e.preventDefault(); e.stopPropagation();
      showMsg('NORMALでは貼り付けできません（i で INSERT へ）', 1200);
      return;
    }
    // INSERT：クリップボードからテキスト取得して LF 正規化
    var t = (window.clipboardData && window.clipboardData.getData('Text'));
    if (typeof t === 'string') {
      pushUndo('paste');
      e.preventDefault(); e.stopPropagation();
      // v1 は LF 固定。将来は OPT.fileformat で 'dos' 時に \r\n に正規化。
      t = t.replace(/\r\n?/g, '\n');
      var s = editor.selectionStart, en = editor.selectionEnd, v = editor.value;
      editor.value = v.slice(0, s) + t + v.slice(en);
      var newPos = s + t.length;
      if (editor.setSelectionRange) editor.setSelectionRange(newPos, newPos);
      updateStatus(editor); ensureScrolloff(editor); updateGutter();
    }
    // それ以外（安全のため既定も許可しない）
  });

  // F1 でヘルプ
  window.addEventListener('keydown', function(e){
    if (e.key === 'F1') { e.preventDefault(); toggleHelp(); return; }
    // Help表示中の Esc
    if (e.key === 'Escape' && document.getElementById('help').style.display==='block') {
      e.preventDefault(); hideHelp(); return;
    }
    // ESCで警告メッセージを消す（cmdmsgが表示されている場合も対応）
    if (
      e.key === 'Escape' &&
      showMsg._hold &&
      document.getElementById('cmdmsg').style.display !== 'none'
    ) {
      hideMsg();
      setTimeout(function(){
        document.getElementById('editor').focus();
      }, 0);
      e.preventDefault();
      e.stopPropagation();
      return;
    }
    // メッセージ表示中でも「:」でコマンドバーに切り替え
    if (e.key === ':' && showMsg._hold) {
      hideMsg();
      openCmdBar();
      return;
    }
    // コマンドバー表示中はESCで閉じる
    if (e.key === 'Escape' && document.getElementById('cmdline').style.display === 'inline-block') {
      hideMsg(); // ←追加
      closeCmdBar();
      return;
    }
  });

  // コマンドバー内キー
  var cmd=document.getElementById('cmdline');
  cmd.addEventListener('keydown', function(e){
    if(e.key==='Escape'||e.keyCode===27){
      e.preventDefault(); e.stopPropagation(); hideMsg(); closeCmdBar(); return;
    }
    if(e.key==='Enter'||e.keyCode===13){ e.preventDefault(); e.stopPropagation(); hideMsg(); runCommand(cmd.value||''); return; }
    // TABでファイル名補完
    if(e.key==='Tab'||e.keyCode===9){
      e.preventDefault(); e.stopPropagation();
      var val = cmd.value;
      var m = val.match(/^e(dit)?\s+(.+)$/i);
      if(m){
        var prefix = m[2].trim();
        try {
          var fso = new ActiveXObject("Scripting.FileSystemObject");
          var folder = fso.GetFolder(".");
          var files = [];
          var eFiles = new Enumerator(folder.Files);
          for (; !eFiles.atEnd(); eFiles.moveNext()) {
            var name = String(eFiles.item().Name);
            if(name.toLowerCase().indexOf(prefix.toLowerCase())===0){
              files.push(name);
            }
          }
          if(files.length===1){
            // 1件なら自動補完
            cmd.value = val.replace(prefix, files[0]);
          }else if(files.length>1){
            // 複数候補なら最初の候補で補完
            cmd.value = val.replace(prefix, files[0]);
            showMsg("候補: " + files.join(", "), 2000);
          }else{
            showMsg("候補なし", 1200);
          }
        }catch(_){
          showMsg("補完エラー", 1200);
        }
      }
      return;
    }
  });

  // cmdbar自体へのESC/コマンド切替
  document.getElementById('cmdbar').addEventListener('keydown', function(e){
    if (e.key === 'Escape' && showMsg._hold) {
      hideMsg();
      document.getElementById('editor').focus();
      e.preventDefault();
      e.stopPropagation();
    }
    if (e.key === ':' && showMsg._hold) {
      hideMsg();
      openCmdBar();
      e.preventDefault();
      e.stopPropagation();
    }
  });

  // cmdmsgへのESC/コマンド切替
  document.getElementById('cmdmsg').addEventListener('keydown', function(e){
    if (showMsg._hold && (e.key === 'Escape' || e.key === ':')) {
      hideMsg();
      if (e.key === ':') {
        openCmdBar();
      } else {
        document.getElementById('editor').focus();
      }
      e.preventDefault();
      e.stopPropagation();
    }
  });

  // どこでもESCで警告を消す（window, body, document）
  function globalEscHandler(e){
    var cmdmsgElem = document.getElementById('cmdmsg');
    if (!cmdmsgElem) return; // ←この行を追加
    if (
      e.key === 'Escape' &&
      showMsg._hold &&
      cmdmsgElem.style.display !== 'none'
    ) {
      hideMsg();
      setTimeout(function(){
        document.getElementById('editor').focus();
      }, 0);
      e.preventDefault();
      e.stopPropagation();
      return;
    }
  }
  // グローバルESCハンドラはinit内で即時登録
  window.addEventListener('keydown', globalEscHandler, true);
  document.body.addEventListener('keydown', globalEscHandler, true);
  document.addEventListener('keydown', globalEscHandler, true);
})();
</script>
</body>
</html>
